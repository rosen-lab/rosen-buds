## Running the pipeline
This section will describe how to run the pipeline and also what the pipeline does at every step. The output file structure is also described here.

The pipeline is configured to automatically use the local lab installation of R which has all the required packages installed. To use this version of R, simply call the script directly as a command line executable. To use a different version of R, simply prepend your Rscript executable to the command. The required packages are Seurat 2.0 or greater, readr, tibble, M3Drop, Matrix, and yaml.

To run the script, simply run `/path/to/seurat_pipeline.R params.yml` on the command line, where `params.yml` is the input YAML file. While running, the pipeline will output timestamped logs every time a step is started. These logs will be indented with `-` characters to show the nested loop structure of the pipeline.

The pipeline will require enough RAM to load a full Seurat object with the data, so it should be run on UGER or in an interactive shell. One benefit of using the local lab installation of R is that it is configured to run without `LD_LIBRARY_PATH`. This means you do not need to create a wrapper script to submit it to UGER.

The pipeline will write out the data needed for the next step at the end of every step. If you rerun the pipeline in the same directory, it will look for previously generated files and skip any steps that have already finished. This allows you to restart the pipeline in case it crashes at any point or to rerun the pipeline with new parameters without having to redo every previous step.

Note that the pipeline only checks that files are present, not that they are complete. If the pipeline crashes while writing out files, it will not be able to detect that the files are not complete and will continue to the next step with only partial data. To fix this, simply delete the incomplete files.

Plots will automatically be regenerated if the input YAML file does not match the one that was used to generate them.

If you want to stop the pipeline at a certain step, just leave the parameters for the next step blank (or comment it out). The pipeline will stop at that point for all combinations of previous steps. For example, if you want to examine the PC variation plots before selecting the PCs to use for visualization and clustering, omit the `pcs` parameter. Note that the `include`, `tsne_plot`, `feature_plot`, `violin_plot`, `dot_plot` and `point_size` are optional and omitting them will NOT cause the pipeline to stop.

### The stats.yml file
At several steps throughout pipeline, a file named `stats.yml` will be generated. This file contains various statistics about the data set, such as the number of cells or genes passing filters or the number of clusters in the dataset. Each time it is generated, the stats from previous steps are copied over and the new stats are appended to them. This way each stats file contains all the information contained in stats files from previous steps.

### Creating the top level directory
The top level directory is created using the parameter supplied with the `output_path` key if it does not already exist. Within this directory, the file `session_info.txt` is created at the start of running the pipeline. This file contains the pipeline version as well as the versions of all packages being used. This file is overwritten every time the pipeline is rerun.

### Reading DGEs
Each DGE file specified in the `data` key will be read into a sparse matrix. Paths to the objects must be specified with the `path` subkey for each entry in `dge`. The key for each entry will be prepended to cell names with a `_` for separation to prevent conflicts with overlapping cell names in different DGEs. So a cell named `cell` in a DGE with the key `dge` will be renamed to `dge_cell`. This matrix will be imported into a Seurat file whose metadata is set via the additional fields in the `data` parameter. Any additional subkeys besides `path` in the YAML file will be set in the `meta.data` slot of the Seurat object. Finally this Seurat object is merged with the Seurat object from the previous DGEs. Once all the DGEs are read the `raw.data` and `meta.data` slots will be pulled out and written to `raw_data.rds` and `metadata.rds` respectively. Additionally, the `stats.yml` file will be created with the number of starting genes and cells in the dataset.

### Subsetting cells
If the `include` parameter is set, the pipeline will read in cell names from the file specified by the parameter. Multiple include files can be specified. Only cells that are present in one of the `include` files will be kept. The files `raw_data_filtered.rds` and `metadata_filtered.rds` will be generated using this subset of cells. The `stats.yml` file will also to be updated with the number of cells in the subset.

### Filtering genes
If the `include` parameter is set, data will be read from `raw_data_filtered.rds` and `metadata_filtered.rds`, otherwise it will be read from `raw_data.rds` and `metadata.rds`. This data is used to create a Seurat object. Genes which are present in less than the number of cells specified by the `nCells` key will be filtered out. Additionally, the `orig.ident` slot of the Seurat object is filled with the key for each DGE in the `data` key. A subdirectory will be created named `nCells_x` where `x` is the value of the `nCells` key. The Seurat object and the filtered `raw.data` slot will be written to `seurat.rds` and `raw_data.rds` in this subdirectory. Additionally, a `stats.yml` file will be output with the number of genes passing the filter added. Multiple values of `nCells` can be set and this step will be run multiple times.

### Filtering cells and normalizing
The Seurat object will be filtered using the `nGenes` key of the input YAML file. Any cell that has less than that number of unique genes present will be filtered out. The count level data in the `raw.data` slot of the Seurat object will then be log normalized. Seurat normalizes to a library size of 10,000 counts and uses the natural log. A pseudocount of 1 is added to each gene post normalization but before the log transformation to prevent taking the log of 0. A subdirectory of the `nCells` subdirectory will be created named `nGenes_x` where `x` is the value of the `nGenes` key. The Seurat object and the `data` slot will be written to `seurat.rds` and `data.rds` in this subdirectory. Additionally, a `stats.yml` file will be output with the number of cells passing the filter added. Multiple values of `nGenes` can be set and this step will be run multiple times.

### Filtering cells on mitochondrial content and adding cell cycle information
The mitochondrial content of each cell will be calculated and added to the `meta.data` slot under the name `percent.mito`. For human cells, mitochondrial genes are any genes starting with `MT-`. For mouse cells, mitochondrial genes are any genes starting with `mt-`. The Seurat object will be filtered using the `mito_cutoff` key of the input YAML file. Any cell that has a higher mitochondrial content will be filtered out. For human cells, Cell Cycle Scoring will be performed which calculates an S score and G2M score for each cell. These are saved in the `meta.data` slot as `S.Score` and `G2M.Score`. Additionally, the difference between the S and G2M scores is saved as `CC.difference` and a categorical identity (S, G2M, or G1) will be stored as `Phase`. For more information on cell cycle scoring, click [here](http://satijalab.org/seurat/cell_cycle_vignette.html). A subdirectory of the `nGenes` subdirectory will be created named `mito_x` where `x` is the value of the `mito_cutoff` key. The Seurat object and the `data` slot will be written to `seurat.rds` and `data.rds` in this subdirectory. Additionally, a `stats.yml` file will be output with the number of cells passing the filter added. Multiple values of `mito_cutoff` can be set and this step will be run multiple times.

### Scaling data, batch correction, and gene significance testing
The normalized data in the `data` slot of the Seurat object will be scaled using z-scores. Additionally, any batch effects specified with the `batches` key will be regressed out during this scaling. This scaled and batch corrected data will be stored in the `scale.data` slot. Testing for variable genes is also performed in this step with the `data` slot using the [M3Drop](https://bioconductor.org/packages/release/bioc/html/M3Drop.html) method. A subdirectory of the `mito` subdirectory will be created named `batch_x` where `x` is the name of the `batches` key. The Seurat object, the `scale.data` slot, and the results of M3Drop will be written to `seurat.rds`, `scale_data.rds`, and `variable_genes.tsv` in this subdirectory. Multiple values of `batches` can be set and this step will be run multiple times. Additionally, each value of `batches` can be list and those batches will be regressed out simultaneously.

### Variable gene selection and running PCA
The value of the `variable_genes` key will be used to select genes to be used for PCA. If this value is less than 1, it is interpreted as an FDR cutoff and all genes with FDR less than this will be selected. If it is greater than 1, it will be interpreted as a number of genes to use and that many genes will be selected in order of FDR. The first 50 PCs will be run on the `scale.data` values of these selected genes. A subdirectory of the `batch` subdirectory will be created named `var_genes_x` where `x` is the value of the `variable_genes` key. The Seurat object, the PC loading coefficients, and PC variance plots will be written to `seurat.rds`, `pc_loadings.tsv`, and `pc_variation.pdf` in this subdirectory. Additionally, a `stats.yml` file will be output with the number of genes selected added. Multiple values of `variable_genes` can be set and this step will be run multiple times. 

### PC selection, running tSNE, building SNN, and making marker tSNE plots
The value of the `pcs` key will be used to select the PCs to use for tSNE visualization and SNN-based clustering. If this value is less than 1, it is interpreted as a variance cutoff and the first `n` PCs will be selected where the total variance of the `n` PCs accounts for more of the total fraction of variance in the 50 PCs than the cutoff. If it is greater than 1, it will be interpreted as a number of PCs to select. tSNE will be run on the Seurat object using the selected PCs to project the data into two dimensions for visualization. A SNN graph is also generated from these PCs which will later be used for clustering. A subdirectory of the `var_genes` subdirectory will be created named `PCs_x` where `x` is the value of the `pcs` key. The Seurat object will be written to `seurat.rds` in this subdirectory. tSNE plots of the top 36 most variable genes from M3Drop will be generated and written to `tSNE_plots_M3D.pdf` in this subdirectory. Additionally, a `stats.yml` file will be output with the PCs selected added. Multiple values of `pcs` can be set and this step will be run multiple times. 

### Making user-defined tSNE plots
The values of the `feature_plot` and `tsne_plot` keys will be used to select features to show on tSNE plots. `feature_plot` is used to specify categorical metadata while `tsne_plot` is used for both numerical metadata and gene expression. A warning will be written for any features that could not be found in the Seurat object. A plot of the `orig.ident` is also always generated automatically. The value of the `point_size` key is used to set the point size in the tSNE plots. If this is not provided, it defaults to 1. These plots will all be written to a file `tSNE_plots.pdf` within the `PCs` subdirectory. Additionally, the `feature_plot` and `tsne_plot` keys will be written to a file `tSNE_plots.yml` within the `PCs` subdirectory.

### Clustering data and making marker dot plots
Clustering will be performed on the SNN graph generated previously. The value of the `res` key will be used to set the clustering resolution. Hierarchical clustering of these clusters is also performed and used to set the cluster identities in order of similarity. A subdirectory of the `pcs` subdirectory will be created named `res_x` where `x` is the value of the `res` key. The Seurat object will be written to `seurat.rds` in this subdirectory. A tSNE plot of the clusters and a tree showing the clustering of the clusters is written to `cluster_plots.pdf` in this subdirectory. The most recent versions of `raw_data.rds`, `data.rds`, `scale_data.rds` as well as `variable_genes.tsv`, `pc_loadings.tsv`, `pc_variation.pdf`, `tSNE_plots_M3D.pdf`, and `tSNE_plots.pdf` will be linked in this subdirectory. `session_info.txt` is also copied to this subdirectory. Additionally, a `stats.yml` file will be output with the number of clusters found. Multiple values of `res` can be set and this step will be run multiple times.

### Making user-defined violin plots
The value of the `violin_plot` key will be used to select features to show on violin plots. A warning will be written for any features that could not be found in the Seurat object. Plots of `percent.mito`, `nUMI`, and `nGene` are also always generated automatically. The `nUMI` and `nGene` plots are on logarithmic y-axes, all others are on linear y-axes. The value of the `point_size` key is used to set the point size in the violin plots. If this is not provided, it defaults to 1. These plots will all be written to a file `violin_plots.pdf` within the `res` subdirectory. Additionally, the `violin_plot` key will be written to a file `violin_plots.yml` in this subdirectory.

### Making user-defined dot plots
The value of the `dot_plot` key will be used to select features to show on dot plots. A warning will be written for any features that could not be found in the Seurat object. These plots will all be written to a file `dot_plots.pdf` within the `res` subdirectory. Additionally, the `dot_plot` key will be written to a file `dot_plots.yml` in this subdirectory.
