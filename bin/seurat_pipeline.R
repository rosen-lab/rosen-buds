#! /broad/rosenlab_archive/Software/local/bin/Rscript
pipeline_version <- "0.7.0"

cat(format(Sys.time(), "[%H:%M:%S]"), "Loading libraries\n")

suppressMessages(library(methods))
suppressMessages(library(Seurat))
suppressMessages(library(readr))
suppressMessages(library(tibble))
suppressMessages(library(M3Drop))
suppressMessages(library(Matrix))
suppressMessages(library(viridis))
suppressMessages(library(yaml))
suppressMessages(library(ggExtra))
suppressMessages(library(grid))

########################## FUNCTIONS ##########################
# Convenience function to make directory if it doesn't already exist
make_dir <- function(dir) {
  if (!dir.exists(dir)) {
    dir.create(dir)
  }
}

# Convenience function to timestamp output
cat_time <- function(x) {
  cat(format(Sys.time(), "[%H:%M:%S]"), x)
}

# Convenience function to cat string generated by sprintf
catf <- function(format, ...) {
  cat_time(sprintf(format, ...))
}

# Convenience function to read in one variable from R object file
load_obj <- function(fileName) {
  local_env <- new.env()
  name <- load(file = fileName, envir = local_env)
  return(get(name, envir = local_env))
}

# Write matrix to tsv, works for sparse matrices and adds column name Gene to rownames
matrix_to_tsv <- function(mat, file) {
  write_tsv(rownames_to_column(as.data.frame(as.matrix(mat)), "GENE"), file)
}

# Read potentially sparse matrix from tsv
tsv_to_matrix <- function(file, sparse = TRUE, int = FALSE) {
  if (int) {
    default <- col_integer()
  } else {
    default <- col_double()
  }
  dat <- read_tsv(
    file, progress = FALSE,
    col_types = cols("GENE" = col_character(), .default = default)
  )
  dat <- as.matrix(column_to_rownames(data.frame(dat), "GENE"))
  if (sparse) {
    dat <- as(dat, "dgCMatrix")
  }
  return(dat)
}

# Function to save seurat object, writing data matrices to seperate files
save_seurat <- function(x, loc, raw = FALSE, data = FALSE, scale = FALSE) {
  # Save data as seperate gzipped tsvs
  if (raw) {
    saveRDS(x@raw.data, file.path(loc, "raw_data.rds"))
  }
  if (data) {
    saveRDS(x@data, file.path(loc, "data.rds"))
  }
  if (scale) {
    saveRDS(x@scale.data, file.path(loc, "scale_data.rds"))
  }
  # Remove data from object and save
  x@raw.data <- NULL
  x@data <- NULL
  x@scale.data <- NULL
  saveRDS(x, file.path(loc, "seurat.rds"))
}

# Function to load seurat object and rebuild it's data slots
build_seurat <- function(seurat_path, raw_data_path = NULL, data_path = NULL, scale_data_path = NULL) {
  x <- readRDS(file.path(seurat_path, "seurat.rds"))
  if (!is.null(raw_data_path)) {
    x@raw.data <- readRDS(file.path(raw_data_path, "raw_data.rds"))
  }
  if (!is.null(data_path)) {
    x@data <- readRDS(file.path(data_path, "data.rds"))
  }
  if (!is.null(scale_data_path)) {
    x@scale.data <- readRDS(file.path(scale_data_path, "scale_data.rds"))
  }
  return(x)
}

# Function to return all M3Drop scores for all genes
find_M3Drop_markers <- function(x) {
  # Unlog data
  x <- expm1(x)
  # Remove empty genes (potentially due to rounding)
  x <- x[Matrix::rowSums(x) > 0, ]

  # Run M3
  markers <- M3DropFeatureSelection(x, "fdr", 1.1, suppress.plot = T)

  # Reformat and sort dataframe
  markers$Gene <- as.character(markers$Gene)
  names(markers)[4] <- "FDR"
  markers <- markers[with(markers, order(FDR, p.value, -effect.size)), ]

  return(markers)
}

# Function to make PC variation plots based on PC standard deviation
make_pc_plots <- function(sdev, file) {
  var <- sdev^2
  cum_var <- cumsum(var)/sum(var)
  df <- data.frame(PC = 1:length(cum_var), var = var, cum_var = cum_var)

  pdf(file)

  # Make cumulative variation plot
  p1 <- ggplot(df, aes(x = PC, y = cum_var)) + geom_point() + expand_limits(y = 0)
  p1 <- p1 + labs(x = "PC", y = "Cumulative Proportion of Variation", title = "PC Cumulative Proportion of Variation")
  print(p1)

  # Make variation plot
  p2 <- ggplot(df, aes(x = PC, y = var)) + geom_point() + expand_limits(y = 0)
  p2 <- p2 + labs(x = "PC", y = "Variance", title = "PC Variance")
  print(p2)

  invisible(dev.off())
}

# Function to make dot plots with plasma colorscale
# Needed since DotPlot generates a plot always
make_dot_plots <- function(seurat, features) {
  pdf(NULL)
  p <- DotPlot(seurat, features, do.return = TRUE, plot.legend = TRUE, x.lab.rot = TRUE)
  invisible(dev.off())
  suppressMessages(p <- p + scale_color_viridis(option = "plasma", direction = -1))
  print(p)
}

# Function to calculate mitochondrial percent for each cell
calc_percent_mito <- function(x, species) {
  # Unlog data
  x <- expm1(x)

  # Pull out mitochondrial genes based on species naming convention
  if (toupper(species) == "MOUSE") {
    mito <- grep("^mt-", row.names(x))
  } else {
    mito <- grep("^MT-", row.names(x))
  }

  # Return mitochondrial percent
  return(Matrix::colSums(x[mito, ])/Matrix::colSums(x))
}

# Convenience function to convert every element of x is numeric
# Exits if any element is non numeric
to_numeric <- function(x, name) {
  y <- suppressWarnings(as.numeric(x))
  if (any(is.na(y))) {
    i <- which(is.na(y))[1]
    stop(sprintf("%s value \"%s\" is not a number", name, x[i]))
  }
  return(y)
}

# Function to check whether the features in params variable are the same as
# those stored in yaml file
compare_params <- function(params, file, features) {
  params_file <- yaml.load_file(file)
  # Make sure all features are found in both params
  if (any(!features %in% names(params_file))) {
    missing <- which(!features %in% names(params_file))
    warning(sprintf("Could not find %s in %s\n", missing, file))
    return(FALSE)
  }
  if (any(!features %in% names(params))) {
    missing <- which(!features %in% names(params))
    missing <- features[missing]
    warning(sprintf("Could not find %s in input params\n", missing))
    return(FALSE)
  }

  # Check each feature is the same
  for(feature in features) {
    params_f <- unlist(params[[feature]])
    params_file_f <- unlist(params_file[[feature]])
    if(length(params_f) != length(params_file_f)) {
      return(FALSE)
    }
    if (any(params_f != params_file_f)) {
      return(FALSE)
    }
  }

  return(TRUE)
}

# Function to ensure all fields in params are formatted correctly
# Exits if an issue is detected
check_params <- function(params) {
  for (i in 1:length(params$data)) {
    dge <- params$data[[i]]
    name <- names(params$data)[i]
    if (is.null(dge$path)) {
      stop(sprintf("No data path found for sample %s", name))
    }
    if (!file.exists(dge$path)) {
      stop(sprintf("File %s does not exist", dge$path))
    }
  }

  for (include in params$include) {
    if (!file.exists(include)) {
      stop(sprintf("File %s does not exist", include))
    }
  }

  if (is.null(params$point_size)) {
    params$point_size <- 1
  } else if (length(params$point_size) != 1) {
    stop("point_size must be a scalar")
  } else {
    params$point_size <- to_numeric(params$point_size)
  }

  params$nCells <- to_numeric(params$nCells, "nCells")
  params$nGenes <- to_numeric(params$nGenes, "nGenes")
  params$mito_cutoff <- to_numeric(params$mito_cutoff, "mito_cutoff")
  params$variable_genes <- to_numeric(params$variable_genes, "variable_genes")
  params$pcs <- to_numeric(params$pcs, "PCs")
  params$resolution <- to_numeric(params$resolution, "resolution")

  return(params)
}

# Append data to stats.yml file or create new one if it doesn't already exist
output_stats <- function(x, out_dir, in_dir = NULL) {
  if (!is.null(in_dir)) {
    y <- yaml.load_file(file.path(in_dir, "stats.yml"))
    x <- c(y, x)
  }
  out_file <- file.path(out_dir, "stats.yml")
  write_yaml(x, out_file)
}

# Convenience function to check all files exist within path
all_exists <- function(path, files) {
  for (file in files) {
    if (!file.exists(file.path(path, file))) {
      return(FALSE)
    }
  }
  return(TRUE)
}

# Convenience function to check whether features can be found by fetchData
# Gives warnings for every missing feature, returns list of non-missing features
check_features <- function(features, seurat) {
  out <- c()
  for (feature in features) {
    x <- tryCatch(
      FetchData(seurat, feature),
      error = function(e) {
        warning(paste(feature, "not found, omitting from plot"), call. = FALSE, immediate. = TRUE)
        return(NULL)
      }
    )
    if (!is.null(x)) {
      out <- c(out, feature)
    }
  }
  return(out)
}

########################## PIPELINE ##########################
cat_time("Checking and loading params file\n")
args <- commandArgs(trailingOnly = TRUE)
params <- yaml.load_file(args[1])
params <- check_params(params)

make_dir(params$output_path)
setwd(params$output_path)

# Print session info
cat(sprintf("Seurat pipeline version %s\n", pipeline_version), file = "session_info.txt")
capture.output(sessionInfo(), file = "session_info.txt", append = TRUE)

# Merge DGEs
if (all_exists(".", c("raw_data.rds", "metadata.rds"))) {
  cat_time("DGEs already read\n")
} else {
  for (i in 1:length(params$data)) {
    dge <- params$data[[i]]
    name <- names(params$data)[i]

    catf("Reading data from %s\n", name)
    data <- tsv_to_matrix(dge$path, int = TRUE)
    colnames(data) <- paste(name, colnames(data), sep = "_")

    # Add metadata if it exists
    if (length(dge) > 1) {
      metadata <- data.frame(dge[names(dge) != "path"])
      metadata <- metadata[rep(1, ncol(data)), ]
      row.names(metadata) <- colnames(data)
      new_seurat <- CreateSeuratObject(data, project = name, meta.data = metadata)
    } else{
      new_seurat <- CreateSeuratObject(data, project = name)
    }

    # Create seurat object on first pass, merge on subsequent passes
    if (i == 1) {
      seurat <- new_seurat
    } else {
      seurat <- MergeSeurat(seurat, new_seurat, do.normalize = FALSE)
    }
  }

  # Extract transgenes to metadata
  if (!is.null(params$transgenes)) {
    cat_time("Extracting transgenes\n")
    for (gene in params$transgenes) {
      if (any(row.names(seurat@raw.data) == gene)) {
      loc <- which(row.names(seurat@raw.data) == gene)[1]
      seurat@metadata[, gene] <- seurat@raw.data[loc, ]
      seurat@raw.data <- seurat@raw.data[-loc, ]
      } else {
      warning(sprintf("Could not find transgene %s in data\n"), gene)
      }
    }
    seurat@meta.data$nGene <- colSums(seurat@raw.data > seurat@is.expr)
    seurat@meta.data$nUMI <- colSums(seurat@raw.data)
  }


  # Plot nUMI/nGene distributions
  cat_time("Plotting nUMI/nGene distributions\n")
  pdf("UMI_gene_distributions.pdf")
  p <- ggplot(seurat@meta.data, aes(x=nUMI, y=nGene))
  p <- p + geom_point(alpha=0.3, stroke=0)
  print(ggMarginal(p, fill="lightgray"))
  grid.newpage()
  RidgePlot(seurat, c("nUMI", "nGene"), nCol = 2)
  invisible(dev.off())

  # Write raw.data, metadata, and starting dimensions
  cat_time("Writing merged data\n")
  saveRDS(seurat@raw.data, "raw_data.rds")
  saveRDS(seurat@meta.data, "metadata.rds")
  output_stats(
    list(
      "Starting genes" = dim(seurat@raw.data)[1],
      "Starting cells" = dim(seurat@raw.data)[2]),
    getwd()
  )

  rm(dge, i, name, new_seurat, seurat)
}

# Subset cells based on file
if (!is.null(params$include)) {
  if (all_exists(".", c("raw_data_filtered.rds", "metadata_filtered.rds"))) {
    cat_time("Cells already filtered\n")
  } else {
    cat_time("Filtering cells\n")
    cells <- c()
    for (include in params$include) {
      cells <- c(cells, scan(include, character(), quiet = TRUE))
    }

    metadata <- readRDS("metadata.rds")
    data <- readRDS("raw_data.rds")

    metadata <- metadata[row.names(metadata) %in% cells, ]
    data <- data[, colnames(data) %in% cells]

    # Plot nUMI/nGene distributions
    cat_time("Plotting nUMI/nGene distributions\n")
    pdf("UMI_gene_distributions_filtered.pdf")
    p <- ggplot(seurat@meta.data, aes(x=nUMI, y=nGene))
    p <- p + geom_point(alpha=0.3, stroke=0)
    print(ggMarginal(p, fill="lightgray"))
    grid.newpage()
    RidgePlot(seurat, c("nUMI", "nGene"), nCol = 2)
    invisible(dev.off())

    saveRDS(metadata, "metadata_filtered.rds")
    saveRDS(data, "raw_data_filtered.rds")

    output_stats(
      list("Included cells" = dim(data)[2]),
      getwd()
    )
  }
}

# Start iterative pipeline
# Create seurat object and filter genes
for (nCells in params$nCells) {
  cell_path <- sprintf("nCells_%i", nCells)

  # Skip if already ran
  if (all_exists(cell_path, c("seurat.rds", "raw_data.rds"))) {
    catf("- %i cell cutoff already ran\n", nCells)
  } else {
    catf("- Filtering out genes present in < %i cells\n", nCells)

    if (is.null(params$include)) {
      metadata <- readRDS("metadata.rds")
      data <- readRDS("raw_data.rds")
    } else {
      metadata <- readRDS("metadata_filtered.rds")
      data <- readRDS("raw_data_filtered.rds")
    }

    seurat <- CreateSeuratObject(data, project = params$project_name, min.cells = nCells, meta.data = metadata)
    
    # Use everything but last field seperated by _ as original identity
    ident <- strsplit(rownames(seurat@meta.data), "_(?=[^_]+$)", perl=TRUE)
    ident <- as.factor(sapply(ident, function (x) x[1]))
    seurat@meta.data$orig.ident <- ident
    seurat@ident <- ident
    names(seurat@ident) <- row.names(seurat@meta.data)

    # Write raw.data, seurat object, and number of genes
    make_dir(cell_path)
    save_seurat(seurat, cell_path, raw = TRUE)
    output_stats(
      list("Genes post cell filter" = dim(seurat@raw.data)[1]),
      cell_path, getwd()
    )
  }

  # Filter cells on number of genes
  for (nGenes in params$nGenes) {
    gene_path <- file.path(cell_path, sprintf("nGenes_%i", nGenes))

    # Skip if already ran
    if (all_exists(gene_path, c("seurat.rds", "data.rds"))) {
      catf("-- %i gene filter and normalization already ran\n", nGenes)
    } else {
      catf("-- Filtering out cells with < %i genes\n", nGenes)

      seurat <- build_seurat(cell_path, raw_data_path = cell_path)
      seurat <- FilterCells(seurat, "nGene", nGenes)
      seurat <- NormalizeData(seurat, display.progress = FALSE)

      # Write data, seurat object, and number of cells
      make_dir(gene_path)
      save_seurat(seurat, gene_path, data = TRUE)
      output_stats(
        list("Cells post gene filter" = dim(seurat@data)[2]),
        gene_path, cell_path
      )
    }

    # Filter on mitochondrial content
    for (mito_cutoff in params$mito_cutoff) {
      mito_path <- file.path(gene_path, sprintf("mito_%s", as.character(mito_cutoff)))

      if (all_exists(mito_path, c("seurat.rds", "data.rds"))) {
        catf("--- %s mitochondrial filter already ran\n",as.character(mito_cutoff))
      } else {
        catf("--- Filtering out cells with > %s mitochondrial reads\n", as.character(mito_cutoff))

        seurat <- build_seurat(gene_path, data_path = gene_path)

        # Calculate percent mitochondrial, add to seurat, and filter on it
        percent_mito <- calc_percent_mito(seurat@data, params$species)
        seurat <- AddMetaData(seurat, percent_mito, "percent.mito")
        seurat <- FilterCells(seurat, subset.names = "percent.mito", high.thresholds = mito_cutoff)

        # Add cell cycle info to metadata for human data
        if (params$species == "human") {
          data(cc.genes)
          s_genes <- readLines("/broad/rosenlab_archive/Data/CellCycle/Human/S_genes.txt")
          g2m_genes <- readLines("/broad/rosenlab_archive/Data/CellCycle/Human/G2M_genes.txt")
          seurat <- CellCycleScoring(seurat, s.genes = cc.genes$s.genes, g2m.genes = cc.genes$g2m.genes)
          seurat@meta.data$CC.Difference <- seurat@meta.data$S.Score - seurat@meta.data$G2M.Score
        }

        # Write data, seurat object, and number of cells
        make_dir(mito_path)
        save_seurat(seurat, mito_path, data = TRUE)
        output_stats(
          list("Cells post mitochondrial filter" = dim(seurat@data)[2]),
          mito_path, gene_path
        )
      }

      # Scale data and regress out batch effects
      for (i in 1:length(params$batches)) {
        name <- names(params$batches)[i]
        batch <- params$batches[[i]]
        batch_path <- file.path(mito_path, sprintf("batch_%s", name))

        if (all_exists(batch_path, c("seurat.rds", "scale_data.rds", "variable_genes.tsv"))) {
          catf("---- Batch %s correction, data scaling, and gene significance calculation already ran\n", name)
        } else {
          catf("---- Scaling data, regressing batch %s, and calculating gene significance\n", name)

          seurat <- build_seurat(mito_path, data_path = mito_path)

          # Only regress on batch if a batch was provided
          if (is.null(batch)) {
            seurat <- ScaleData(seurat, display.progress = FALSE)
          } else {
            seurat <- ScaleData(seurat, display.progress = FALSE, vars.to.regress = batch)
          }

          # Get M3Drop markers
          markers <- find_M3Drop_markers(seurat@data)

          # Write scale.data, seurat object, and results of M3Drop
          make_dir(batch_path)
          save_seurat(seurat, batch_path, scale = TRUE)
          write_tsv(markers, file.path(batch_path, "variable_genes.tsv"))
        }

        # Run PCA
        for (var_genes in params$variable_genes) {
          var_path <- file.path(batch_path, sprintf("var_genes_%s", as.character(var_genes)))

          if (file.exists(file.path(var_path, "seurat.rds"))) {
            catf("----- %s variable genes already ran\n", as.character(var_genes))
          } else {
            if (var_genes < 1) {
              catf("----- Finding variable genes with FDR < %s and running PCA\n", as.character(var_genes))              
            } else {
              catf("----- Finding %s most variable genes by FDR and running PCA\n", as.character(var_genes))              
            }

            seurat <- build_seurat(batch_path, data_path = mito_path, scale_data_path = batch_path)

            # Read M3Drop significance, filter on FDR or just by total number
            markers <- read_tsv(file.path(batch_path, "variable_genes.tsv"), progress = FALSE,
              col_types = cols("Gene" = col_character(), .default = col_double()))
            if (var_genes < 1) {
              seurat@var.genes <- markers$Gene[markers$FDR < var_genes]
            } else {
              if (var_genes > nrow(markers)) {
                catf("----- WARNING: %s variable genes requested, but there are only %i genes, using %i genes\n", as.character(var_genes), nrow(markers), nrow(markers))
                seurat@var.genes <- markers$Gene[1:nrow(markers)]
              } else {
                seurat@var.genes <- markers$Gene[1:var_genes]
              }
            }

            seurat <- RunPCA(seurat, pcs.compute = 50, pcs.print = FALSE)

            # Write PC variation plots, PC loadings, seurat object, and number of variable genes
            make_dir(var_path)
            make_pc_plots(seurat@dr$pca@sdev, file.path(var_path, "pc_variation.pdf"))
            write_tsv(
              rownames_to_column(as.data.frame(seurat@dr$pca@gene.loadings), "GENE"),
              file.path(var_path, "pc_loadings.tsv")
            )
            save_seurat(seurat, var_path)
            output_stats(
              list("Variable genes" = length(seurat@var.genes)),
              var_path, mito_path
            )
          }

          # Run tSNE and build SNN
          for (pc in params$pcs) {
            pc_path <- file.path(var_path, sprintf("PCs_%s", as.character(pc)))

            if (all_exists(pc_path, c("seurat.rds", "tSNE_plots.pdf", "tSNE_plots_M3D.pdf"))) {
              catf("------ %s PCs and tSNE already ran\n", as.character(pc))
            } else {
              if (pc < 1) {
                catf("------ Selecting PCs with cumulative proportion of variance >= %s, running tSNE, building SNN, and plotting marker genes\n", as.character(pc))
              } else {
                catf("------ Selecting %s PCs, running tSNE, and building SNN\n", as.character(pc))
              }
              seurat <- build_seurat(var_path, data_path = mito_path)

              # Select PCs
              if (pc < 1) {
                var <- seurat@dr$pca@sdev^2
                cum_var <- cumsum(var)/sum(var)
                pcs <- 1:which(cum_var >= pc)[1]
              } else {
                pcs <- 1:pc
              }

              seurat <- RunTSNE(seurat, dims.use = pcs)
              seurat <- BuildSNN(seurat, dims.use = pcs, print.output = FALSE)

              # Plot top genes from M3Drop
              make_dir(pc_path)
              markers <- read_tsv(file.path(batch_path, "variable_genes.tsv"), progress = FALSE,
                col_types = cols("Gene" = col_character(), .default = col_double()))
              pdf(file.path(pc_path, "tSNE_plots_M3D.pdf"))
              FeaturePlot(seurat, markers$Gene[1:9], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, markers$Gene[10:18], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, markers$Gene[19:27], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, markers$Gene[28:36], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              invisible(dev.off())

              # Write seurat object and number of PCs used 
              save_seurat(seurat, pc_path)
              output_stats(
                list("PCs used" = length(pcs)),
                pc_path, var_path
              )
            }

            # Make tSNE plots
            if (
              all_exists(pc_path, c("tSNE_plots.pdf", "tSNE_plots.yml")) &&
              compare_params(params, file.path(pc_path, "tSNE_plots.yml"), c("tsne_plot", "feature_plot"))
            ) {
              cat_time("------- tSNE plots already made\n")
            } else {
              cat_time("------- Making tSNE plots\n")
              seurat <- build_seurat(pc_path, data_path = mito_path)

              pdf(file.path(pc_path, "tSNE_plots.pdf"))

              # Default plot
              p <- TSNEPlot(seurat, group.by = "orig.ident", do.return = TRUE, pt.size = params$point_size)
              print(p + ggtitle("Original identity"))

              # User defined categorical plots
              for (feature in params$tsne_plot) {
                feature <- check_features(feature, seurat)
                if (length(feature) == 0) {
                  next
                }
                p <- TSNEPlot(seurat, group.by = feature, do.return = TRUE, pt.size = params$point_size)
                print(p + ggtitle(feature))
              }

              # User defined feature plots
              for (feature in params$feature_plot) {
                feature <- check_features(feature, seurat)
                if (length(feature) == 0) {
                  next
                }
                FeaturePlot(seurat, feature, no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              }

              invisible(dev.off())

              # Save information about what was plotted
              write_yaml(
                list(tsne_plot = params$tsne_plot, feature_plot = params$feature_plot),
                file = file.path(pc_path, "tSNE_plots.yml")
              )
            }

            # Run clustering
            for (res in params$resolution) {
              res_path <- file.path(pc_path, sprintf("res_%s", as.character(res)))

              if (all_exists(res_path, c("seurat.rds", "dot_plots_M3D.pdf", "cluster_plots.pdf"))) {
                catf("-------- Clustering with res %s already ran\n", as.character(res))
              } else {
                catf("-------- Finding clusters with resolution %s\n", as.character(res))
                seurat <- build_seurat(pc_path, data_path = mito_path)

                # Load number of PCs
                pcs <- 1:yaml.load_file(file.path(pc_path, "stats.yml"))$`PCs used`

                g <- capture.output(seurat <- FindClusters(seurat, resolution = res, reuse.SNN = TRUE, print.output = FALSE))
                seurat <- BuildClusterTree(seurat, pcs.use =  pcs, do.reorder = TRUE, reorder.numeric = TRUE, do.plot = FALSE, show.progress = FALSE)

                # Write seurat object and number of clusters found 
                make_dir(res_path)
                save_seurat(seurat, res_path)
                output_stats(
                  list("Clusters" = length(levels(seurat@ident))),
                  res_path, pc_path
                )

                # Plot clusters and cluster tree
                pdf(file.path(res_path, "cluster_plots.pdf"))
                p <- TSNEPlot(seurat, do.return = TRUE, do.label = TRUE, pt.size = params$point_size)
                print(p + ggtitle(sprintf("Clusters with resolution %s", as.character(res))))
                PlotClusterTree(seurat)
                title(sprintf("Cluster tree with resolution %s", res))
                invisible(dev.off)

                # Plot top genes from M3Drop
                markers <- read_tsv(file.path(batch_path, "variable_genes.tsv"), progress = FALSE,
                  col_types = cols("Gene" = col_character(), .default = col_double()))
                pdf(file.path(res_path, "dot_plots_M3D.pdf"))
                TSNEPlot(seurat, do.label = TRUE, pt.size = params$point_size)
                make_dot_plots(seurat, markers$Gene[1:9])
                make_dot_plots(seurat, markers$Gene[10:18])
                make_dot_plots(seurat, markers$Gene[19:27])
                make_dot_plots(seurat, markers$Gene[28:36])
                invisible(dev.off())

                # Link data
                file.symlink("../../../../../../raw_data.rds", res_path)
                file.symlink("../../../../data.rds", res_path)
                file.symlink("../../../scale_data.rds", res_path)
                file.symlink("../../../variable_genes.tsv", res_path)
                file.symlink("../../pc_loadings.tsv", res_path)
                file.symlink("../../pc_variation.pdf", res_path)
                file.symlink("../tSNE_plots_M3D.pdf", res_path)
                file.symlink("../tSNE_plots.pdf", res_path)
                file.copy("session_info.txt", res_path)

                # Link data from top level
                make_dir("links")
                file.symlink(file.path("..", res_path), file.path("links", gsub("/", "-", res_path)))
              }

              # Make violin plots
              if (
                all_exists(res_path, c("violin_plots.pdf", "violin_plots.yml")) &&
                compare_params(params, file.path(res_path, "violin_plots.yml"), "violin_plot")
              ) {
                cat_time("--------- Violin plots already generated\n")
              } else {
                cat_time("--------- Making violin plots\n")
                seurat <- build_seurat(res_path, data_path = mito_path)

                pdf(file.path(res_path, "violin_plots.pdf"))
 
                # Make standard violin plots
                print(VlnPlot(seurat, "percent.mito", point.size.use = params$point_size))
                print(VlnPlot(seurat, "nUMI", y.log = TRUE, point.size.use = params$point_size))
                print(VlnPlot(seurat, "nGene", y.log = TRUE, point.size.use = params$point_size))

                # Make user defined violin plots
                for (feature in params$violin_plot) {
                  feature <- check_features(feature, seurat)
                  if (length(feature) == 0) {
                    next
                  }
                  print(VlnPlot(seurat, feature, point.size.use = params$point_size))
                }

                invisible(dev.off())

                # Save information about what was plotted
                write_yaml(
                  list(violin_plot = params$violin_plot),
                  file.path(res_path, "violin_plots.yml")
                )
              }

              # Make dot plots
              if (
                all_exists(res_path, c("dot_plots.pdf", "dot_plots.yml")) &&
                compare_params(params, file.path(res_path, "dot_plots.yml"), "dot_plot")  
              ) {
                cat_time("--------- Dot plots already generated\n")
              } else {
                cat_time("--------- Making dot plots\n")
                seurat <- build_seurat(res_path, data_path = mito_path)
                
                pdf(file.path(res_path, "dot_plots.pdf"))
                TSNEPlot(seurat, do.label = TRUE, pt.size = params$point_size)
                for (feature in params$dot_plot) {
                  feature <- check_features(feature, seurat)
                  if (length(feature) == 0) {
                    next
                  }
                  make_dot_plots(seurat, feature)
                }
                invisible(dev.off())

                # Save information about what was plotted
                write_yaml(
                  list(dot_plot = params$dot_plot),
                  file.path(res_path, "dot_plots.yml")
                )
              }
            }
          }
        }
      }
    }
  }
}
