#! /broad/rosenlab_archive/Software/local/bin/Rscript
pipeline_version <- "0.9.1"

cat(format(Sys.time(), "[%H:%M:%S]"), "Loading R libraries\n")

suppressMessages(library(methods))
suppressMessages(library(Seurat))
suppressMessages(library(readr))
suppressMessages(library(tibble))
suppressMessages(library(M3Drop))
suppressMessages(library(Matrix))
suppressMessages(library(viridis))
suppressMessages(library(yaml))
suppressMessages(library(ggExtra))
suppressMessages(library(grid))

########################## FUNCTIONS ##########################
# Convenience function to make directory if it doesn't already exist
make_dir <- function(dir) {
  if (!dir.exists(dir)) {
    dir.create(dir)
  }
}

# Convenience function to timestamp output
cat_time <- function(x) {
  cat(format(Sys.time(), "[%H:%M:%S]"), x)
}

# Convenience function to cat string generated by sprintf
catf <- function(format, ...) {
  cat_time(sprintf(format, ...))
}

# Convenience function to read in one variable from R object file
load_obj <- function(fileName) {
  local_env <- new.env()
  name <- load(file = fileName, envir = local_env)
  return(get(name, envir = local_env))
}

# Write matrix to tsv, works for sparse matrices and adds column name Gene to rownames
matrix_to_tsv <- function(mat, file) {
  write_tsv(rownames_to_column(as.data.frame(as.matrix(mat)), "GENE"), file)
}

# Read potentially sparse matrix from tsv
tsv_to_matrix <- function(file, sparse = TRUE, int = FALSE) {
  if (int) {
    default <- col_integer()
  } else {
    default <- col_double()
  }
  dat <- read_tsv(
    file, progress = FALSE,
    col_types = cols("GENE" = col_character(), .default = default)
  )
  dat <- as.matrix(column_to_rownames(data.frame(dat), "GENE"))
  if (sparse) {
    dat <- as(dat, "dgCMatrix")
  }
  return(dat)
}

# Function to save seurat object, writing data matrices to seperate files
save_seurat <- function(x, loc, raw = FALSE, data = FALSE, scale = FALSE) {
  # Save data as seperate gzipped tsvs
  if (raw) {
    saveRDS(x@raw.data, file.path(loc, "raw_data.rds"))
  }
  if (data) {
    saveRDS(x@data, file.path(loc, "data.rds"))
  }
  if (scale) {
    saveRDS(x@scale.data, file.path(loc, "scale_data.rds"))
  }
  # Remove data from object and save
  x@raw.data <- NULL
  x@data <- NULL
  x@scale.data <- NULL
  saveRDS(x, file.path(loc, "seurat.rds"))
}

# Function to load seurat object and rebuild it's data slots
build_seurat <- function(seurat_path, raw_data_path = NULL, data_path = NULL, scale_data_path = NULL) {
  x <- readRDS(file.path(seurat_path, "seurat.rds"))
  if (!is.null(raw_data_path)) {
    x@raw.data <- readRDS(file.path(raw_data_path, "raw_data.rds"))
  }
  if (!is.null(data_path)) {
    x@data <- readRDS(file.path(data_path, "data.rds"))
  }
  if (!is.null(scale_data_path)) {
    x@scale.data <- readRDS(file.path(scale_data_path, "scale_data.rds"))
  }
  return(x)
}

# Function to return all M3Drop scores for all genes
find_M3Drop_markers <- function(x) {
  # Unlog data
  x <- expm1(x)
  # Remove empty genes (potentially due to rounding)
  x <- x[Matrix::rowSums(x) > 0, ]

  # Run M3
  markers <- M3DropFeatureSelection(x, "fdr", 1.1, suppress.plot = T)

  # Reformat and sort dataframe
  markers$Gene <- as.character(markers$Gene)
  names(markers)[4] <- "FDR"
  markers <- markers[with(markers, order(FDR, p.value, -effect.size)), ]

  return(markers)
}

# Function to make PC variation plots based on PC standard deviation
make_pc_plots <- function(sdev, file) {
  var <- sdev^2
  cum_var <- cumsum(var)/sum(var)
  df <- data.frame(PC = 1:length(cum_var), var = var, cum_var = cum_var)

  pdf(file)

  # Make cumulative variation plot
  p1 <- ggplot(df, aes(x = PC, y = cum_var)) + geom_point() + expand_limits(y = 0)
  p1 <- p1 + labs(x = "PC", y = "Cumulative Proportion of Variation", title = "PC Cumulative Proportion of Variation")
  print(p1)

  # Make variation plot
  p2 <- ggplot(df, aes(x = PC, y = var)) + geom_point() + expand_limits(y = 0)
  p2 <- p2 + labs(x = "PC", y = "Variance", title = "PC Variance")
  print(p2)

  invisible(dev.off())
}

# Function to make dot plots with plasma colorscale
# Needed since DotPlot generates a plot always
make_dot_plots <- function(seurat, features) {
  pdf(NULL)
  p <- DotPlot(seurat, features, do.return = TRUE, plot.legend = TRUE, x.lab.rot = TRUE)
  invisible(dev.off())
  suppressMessages(p <- p + scale_color_viridis(option = "plasma", direction = -1))
  print(p)
}

# Function to calculate mitochondrial percent for each cell
calc_percent_mito <- function(x, species) {
  # Unlog data
  x <- expm1(x)

  # Pull out mitochondrial genes based on species naming convention
  if (toupper(species) == "MOUSE") {
    mito <- grep("^mt-", row.names(x))
  } else {
    mito <- grep("^MT-", row.names(x))
  }

  # Return mitochondrial percent
  return(Matrix::colSums(x[mito, ])/Matrix::colSums(x))
}

# Convenience function to convert every element of x is numeric
# Exits if any element is non numeric
to_numeric <- function(x, name) {
  y <- suppressWarnings(as.numeric(x))
  if (any(is.na(y))) {
    i <- which(is.na(y))[1]
    stop(sprintf("%s value \"%s\" is not a number", name, x[i]))
  }
  return(y)
}

# Function to check whether the features in params variable are the same as
# those stored in yaml file
compare_params <- function(params, file, features) {
  params_file <- yaml.load_file(file)
  # Make sure all features are found in both params
  if (any(!features %in% names(params_file))) {
    missing <- which(!features %in% names(params_file))
    warning(sprintf("Could not find %s in %s\n", missing, file))
    return(FALSE)
  }
  if (any(!features %in% names(params))) {
    missing <- which(!features %in% names(params))
    missing <- features[missing]
    warning(sprintf("Could not find %s in input params\n", missing))
    return(FALSE)
  }

  # Check each feature is the same
  for(feature in features) {
    params_f <- unlist(params[[feature]])
    params_file_f <- unlist(params_file[[feature]])
    if(length(params_f) != length(params_file_f)) {
      return(FALSE)
    }
    if (any(params_f != params_file_f)) {
      return(FALSE)
    }
  }

  return(TRUE)
}

# Function to ensure all fields in params are formatted correctly
# Exits if an issue is detected
check_params <- function(params) {
  for (i in 1:length(params$data)) {
    dge <- params$data[[i]]
    name <- names(params$data)[i]
    if (is.null(dge$path)) {
      stop(sprintf("No data path found for sample %s", name))
    }
    if (!file.exists(dge$path)) {
      stop(sprintf("File %s does not exist", dge$path))
    }
  }

  for (include in params$include) {
    if (!file.exists(include)) {
      stop(sprintf("File %s does not exist", include))
    }
  }

  if (is.null(params$point_size)) {
    params$point_size <- 1
  } else if (length(params$point_size) != 1) {
    stop("point_size must be a scalar")
  } else {
    params$point_size <- to_numeric(params$point_size)
  }

  params$nCells <- to_numeric(params$nCells, "nCells")
  params$nUMIs <- to_numeric(params$nUMIs, "nUMIs")
#   params$nGenes <- to_numeric(params$nGenes, "nGenes")
  params$mito_cutoff <- to_numeric(params$mito_cutoff, "mito_cutoff")
  params$variable_genes <- to_numeric(params$variable_genes, "variable_genes")
  params$pcs <- to_numeric(params$pcs, "PCs")
  params$resolution <- to_numeric(params$resolution, "resolution")

  return(params)
}

# Append data to stats.yml file or create new one if it doesn't already exist
output_stats <- function(x, out_dir, in_dir = NULL) {
  if (!is.null(in_dir)) {
    y <- yaml.load_file(file.path(in_dir, "stats.yml"))
    x <- c(y, x)
  }
  out_file <- file.path(out_dir, "stats.yml")
  write_yaml(x, out_file)
}

# Convenience function to check all files exist within path
all_exists <- function(path, files) {
  for (file in files) {
    if (!file.exists(file.path(path, file))) {
      return(FALSE)
    }
  }
  return(TRUE)
}

# Convenience function to check whether features can be found by fetchData
# Gives warnings for every missing feature, returns list of non-missing features
check_features <- function(features, seurat) {
  out <- c()
  for (feature in features) {
    x <- tryCatch(
      FetchData(seurat, feature),
      error = function(e) {
        warning(paste(feature, "not found, omitting from plot"), call. = FALSE, immediate. = TRUE)
        return(NULL)
      }
    )
    if (!is.null(x)) {
      out <- c(out, feature)
    }
  }
  return(out)
}

########################## PIPELINE ##########################
cat_time("Checking and loading params file\n")
args <- commandArgs(trailingOnly = TRUE)
params <- yaml.load_file(args[1])
params <- check_params(params)
using_provided_variable_genes_list <- FALSE

make_dir(params$output_path)
setwd(params$output_path)

#### BEGIN: TEST NEW PARAMS ####
# quit()
#### END: TEST NEW PARAMS ####

# Print session info
cat(sprintf("Seurat pipeline version %s\n", pipeline_version), file = "session_info.txt")
capture.output(sessionInfo(), file = "session_info.txt", append = TRUE)

# Merge DGEs
if (all_exists(".", c("raw_data.rds", "metadata.rds"))) {
  cat_time("DGEs already read\n")
} else {
  for (i in 1:length(params$data)) {
    dge <- params$data[[i]]
    name <- names(params$data)[i]

    catf("Reading data from %s\n", name)
    data <- tsv_to_matrix(dge$path, int = TRUE)
    colnames(data) <- paste(name, colnames(data), sep = "_")

    # Add metadata if it exists
    if (length(dge) > 1) {
      metadata <- data.frame(dge[names(dge) != "path"])
      metadata <- metadata[rep(1, ncol(data)), , drop = FALSE] # FIXED: single column data frame no longer auto-converts to vector
      row.names(metadata) <- colnames(data)
      new_seurat <- CreateSeuratObject(data, project = name, meta.data = metadata)
    } else{
      new_seurat <- CreateSeuratObject(data, project = name)
    }

    # Create seurat object on first pass, merge on subsequent passes
    if (i == 1) {
      seurat <- new_seurat
    } else {
      seurat <- MergeSeurat(seurat, new_seurat, do.normalize = FALSE)
    }
  }

  # Extract transgenes to metadata
  if (!is.null(params$transgenes)) {
    cat_time("Extracting transgenes\n")
    for (gene in params$transgenes) {
      if (any(row.names(seurat@raw.data) == gene)) {
      loc <- which(row.names(seurat@raw.data) == gene)[1]
      seurat@meta.data[, gene] <- seurat@raw.data[loc, ]
      seurat@raw.data <- seurat@raw.data[-loc, ]
      } else {
      warning(sprintf("Could not find transgene %s in data\n"), gene)
      }
    }
    seurat@meta.data$nGene <- colSums(seurat@raw.data > seurat@is.expr)
    seurat@meta.data$nUMI <- colSums(seurat@raw.data)
  }

  # Plot nUMI/nGene distributions
  cat_time("Plotting nUMI/nGene distributions\n")
  pdf("UMI_gene_distributions.pdf")
  p <- ggplot(seurat@meta.data, aes(x=nUMI, y=nGene))
  p <- p + geom_point(alpha=0.3, stroke=0)
  print(ggMarginal(p, fill="lightgray"))
  grid.newpage()
  RidgePlot(seurat, c("nUMI", "nGene"), nCol = 2)
  invisible(dev.off())

  # Write raw.data, metadata, and starting dimensions
  cat_time("Writing merged data\n")
  saveRDS(seurat@raw.data, "raw_data.rds")
  saveRDS(seurat@meta.data, "metadata.rds")
  output_stats(
    list(
      "Starting genes" = dim(seurat@raw.data)[1],
      "Starting cells" = dim(seurat@raw.data)[2]),
    getwd()
  )

  rm(dge, i, name, new_seurat, seurat)
}

# Subset cells based on file
if (!is.null(params$include)) {
  if (all_exists(".", c("raw_data_filtered.rds", "metadata_filtered.rds"))) {
    cat_time("Cells already filtered\n")
  } else {
    cat_time("Filtering cells\n")
    cells <- c()
    for (include in params$include) {
      cells <- c(cells, scan(include, character(), quiet = TRUE))
    }

    metadata <- readRDS("metadata.rds")
    data <- readRDS("raw_data.rds")
    seurat <- CreateSeuratObject(data, project = params$project_name, meta.data = metadata)

    metadata <- metadata[row.names(metadata) %in% cells, ]
    data <- data[, colnames(data) %in% cells]

    # Plot nUMI/nGene distributions
    cat_time("Plotting nUMI/nGene distributions\n")
    pdf("UMI_gene_distributions_filtered.pdf")
    p <- ggplot(seurat@meta.data, aes(x=nUMI, y=nGene))
    p <- p + geom_point(alpha=0.3, stroke=0)
    print(ggMarginal(p, fill="lightgray"))
    grid.newpage()
    RidgePlot(seurat, c("nUMI", "nGene"), nCol = 2)
    invisible(dev.off())

    saveRDS(metadata, "metadata_filtered.rds")
    saveRDS(data, "raw_data_filtered.rds")

    output_stats(
      list("Included cells" = dim(data)[2]),
      getwd()
    )
  }
}


# Start iterative pipeline
# Create seurat object and filter genes
for (nCells in params$nCells) {
  cell_path <- sprintf("nCells_%i", nCells)

  # Skip if already ran
  if (all_exists(cell_path, c("seurat.rds", "raw_data.rds"))) {
    catf("- %i cell cutoff already ran\n", nCells)
  } else {
    catf("- Filtering out genes present in < %i cells\n", nCells)

    if (is.null(params$include)) {
      metadata <- readRDS("metadata.rds")
      data <- readRDS("raw_data.rds")
    } else {
      metadata <- readRDS("metadata_filtered.rds")
      data <- readRDS("raw_data_filtered.rds")
    }

    seurat <- CreateSeuratObject(data, project = params$project_name, min.cells = nCells, meta.data = metadata)
    
    # Use everything but last field seperated by _ as original identity
    ident <- strsplit(rownames(seurat@meta.data), "_(?=[^_]+$)", perl=TRUE)
    ident <- as.factor(sapply(ident, function (x) x[1]))
    seurat@meta.data$orig.ident <- ident
    seurat@ident <- ident
    names(seurat@ident) <- row.names(seurat@meta.data)

    # Write raw.data, seurat object, and number of genes
    make_dir(cell_path)
    save_seurat(seurat, cell_path, raw = TRUE)
    output_stats(
      list("Genes post cell filter" = dim(seurat@raw.data)[1]),
      cell_path, getwd()
    )
  }

  # Filter cells on number of UMIs
  for (nUMIs in params$nUMIs) {
    umi_path <- file.path(cell_path, sprintf("nUMIs_%i", nUMIs))

    # Skip if already ran
    if (all_exists(umi_path, c("seurat.rds", "data.rds"))) {
      catf("-- %i gene filter and normalization already ran\n", nUMIs)
    } else {
      catf("-- Filtering out cells with < %i UMIs\n", nUMIs)

      seurat <- build_seurat(cell_path, raw_data_path = cell_path)
      seurat <- FilterCells(seurat, "nUMI", nUMIs)
      seurat <- NormalizeData(seurat, display.progress = FALSE)

      # Write data, seurat object, and number of cells
      make_dir(umi_path)
      save_seurat(seurat, umi_path, data = TRUE)
      output_stats(
        list("Cells post UMI filter" = dim(seurat@data)[2]),
        umi_path, cell_path
      )
    }

    # Filter on mitochondrial content
    for (mito_cutoff in params$mito_cutoff) {
      mito_path <- file.path(umi_path, sprintf("mito_%s", as.character(mito_cutoff)))

      if (all_exists(mito_path, c("seurat.rds", "data.rds"))) {
        catf("--- %s mitochondrial filter already ran\n",as.character(mito_cutoff))
      } else {
        catf("--- Filtering out cells with > %s mitochondrial reads\n", as.character(mito_cutoff))

        seurat <- build_seurat(umi_path, data_path = umi_path)

        # Calculate percent mitochondrial, add to seurat, and filter on it
        percent_mito <- calc_percent_mito(seurat@data, params$species)
        seurat <- AddMetaData(seurat, percent_mito, "percent.mito")
        seurat <- FilterCells(seurat, subset.names = "percent.mito", high.thresholds = mito_cutoff)

        # Add cell cycle info to metadata for human data
        if (params$species == "human") {
          data(cc.genes)
          s_genes <- readLines("/broad/rosenlab_archive/Data/CellCycle/Human/S_genes.txt")
          g2m_genes <- readLines("/broad/rosenlab_archive/Data/CellCycle/Human/G2M_genes.txt")
          seurat <- CellCycleScoring(seurat, s.genes = cc.genes$s.genes, g2m.genes = cc.genes$g2m.genes)
          seurat@meta.data$CC.Difference <- seurat@meta.data$S.Score - seurat@meta.data$G2M.Score
        }

        # Write data, seurat object, and number of cells
        make_dir(mito_path)
        save_seurat(seurat, mito_path, data = TRUE)
        output_stats(
          list("Cells post mitochondrial filter" = dim(seurat@data)[2]),
          mito_path, umi_path
        )
      }

      # Scale data and regress out batch effects
      for (i in 1:length(params$batches)) {
        name <- names(params$batches)[i]
        batch <- params$batches[[i]]
        batch_path <- file.path(mito_path, sprintf("batch_%s", name))

        if (all_exists(batch_path, c("seurat.rds", "scale_data.rds", "variable_genes.tsv"))) {
          catf("---- Batch %s correction, data scaling, and gene significance calculation already ran\n", name)
        } else {
          catf("---- Scaling data, regressing batch %s, and calculating gene significance\n", name)

          seurat <- build_seurat(mito_path, data_path = mito_path)

          # Only regress on batch if a batch was provided
          if (is.null(batch)) {
            seurat <- ScaleData(seurat, display.progress = FALSE)
          } else {
            seurat <- ScaleData(seurat, display.progress = FALSE, vars.to.regress = batch)
          }

          if(all_exists(params$output_path,"variable_genes.tsv")) {
             catf("---- Variable gene list provided: %s\n", file.path(params$output_path,"variable_genes.tsv"))
             make_dir(batch_path)
             file.copy(file.path(params$output_path,"variable_genes.tsv"),file.path(batch_path,"variable_genes.tsv"))
             markers <- read_tsv(file.path(batch_path,"variable_genes.tsv"))
             save_seurat(seurat, batch_path, scale = TRUE)
             using_provided_variable_genes_list <- TRUE
          } else {
            catf("---- Calculating variable genes using M3Drop\n")
            # Get M3Drop markers
            markers <- find_M3Drop_markers(seurat@data)
            # Write scale.data, seurat object, and results of M3Drop
            make_dir(batch_path)
            save_seurat(seurat, batch_path, scale = TRUE)
            write_tsv(markers, file.path(batch_path, "variable_genes.tsv"))
          }
        }

        # Run PCA
        for (var_genes in params$variable_genes) {
          var_path <- file.path(batch_path, sprintf("var_genes_%s", as.character(var_genes)))

          if (file.exists(file.path(var_path, "seurat.rds"))) {
            catf("----- %s variable genes already ran\n", as.character(var_genes))
          } else {
            if (var_genes < 1) {
              catf("----- Finding variable genes with FDR < %s and running PCA\n", as.character(var_genes))              
            } else {
              catf("----- Finding %s most variable genes by FDR and running PCA\n", as.character(var_genes))              
            }

            seurat <- build_seurat(batch_path, raw_data_path = cell_path, data_path = mito_path, scale_data_path = batch_path)
            
            # Read M3Drop significance, filter on FDR or just by total number
            markers <- read_tsv(file.path(batch_path, "variable_genes.tsv"), progress = FALSE,
              col_types = cols("Gene" = col_character(), .default = col_double()))
            if (var_genes < 1) {
              variable_gene_names <- markers$Gene[markers$FDR < var_genes]
            } else {
              if (var_genes > nrow(markers)) {
                catf("----- WARNING: %s variable genes requested, but there are only %i genes, using %i genes\n", as.character(var_genes), nrow(markers), nrow(markers))
                variable_gene_names <- markers$Gene[1:nrow(markers)]
              } else {
                variable_gene_names <- markers$Gene[1:var_genes]
              }
            }
            # Add variable genes "by request"
            if (length(params$variable_genes_add) > 0) {
				catf("----- Appending genes provided to variable genes list\n", as.character(var_genes))              
				variable_gene_names <- union(variable_gene_names,params$variable_genes_add)
			}
            # remove variable genes "by request"
            if (length(params$variable_genes_remove) > 0) {
				catf("----- Excluding genes provided from variable genes list\n", as.character(var_genes))              
				variable_gene_names <- setdiff(variable_gene_names,params$variable_genes_remove)
			}
            seurat@var.genes <- variable_gene_names

            seurat <- RunPCA(seurat, pcs.compute = 60, pcs.print = FALSE)

            # Write PC variation plots, PC loadings, seurat object, and number of variable genes
            make_dir(var_path)
            make_pc_plots(seurat@dr$pca@sdev, file.path(var_path, "pc_variation.pdf"))
            write_tsv(
              rownames_to_column(as.data.frame(seurat@dr$pca@gene.loadings), "GENE"),
              file.path(var_path, "pc_loadings.tsv")
            )
            
			# CCA
			params$cca <- unique(seurat@meta.data$group)
			n_cca <- length(params$cca)
			if (n_cca == 2) {
			    catf("------ Running CCA on (only) 2 groups\n")
				# TODO: CCA yaml param should be list of "accept.values" within a "subset.name" for `SubsetData`
				subseurat_1 <- SubsetData(seurat,subset.name="group",accept.value=params$cca[[1]])
				subseurat_1 <- NormalizeData(subseurat_1,display.progress = FALSE)
				if (is.null(batch)) {
					subseurat_1 <- ScaleData(subseurat_1, display.progress = FALSE)
				} else {
					subseurat_1 <- ScaleData(subseurat_1, display.progress = FALSE, vars.to.regress = batch)
				}
				#subseurat_1@meta.data$group <- names(params$cca)[1]
				subseurat_2 <- SubsetData(seurat,subset.name="group",accept.value=params$cca[[2]])
				subseurat_2 <- NormalizeData(subseurat_2,display.progress = FALSE)
				if (is.null(batch)) {
					subseurat_2 <- ScaleData(subseurat_2, display.progress = FALSE)
				} else {
					subseurat_2 <- ScaleData(subseurat_2, display.progress = FALSE, vars.to.regress = batch)
				}
				#subseurat_2@meta.data$group <- names(params$cca)[2]
				seurat <- RunCCA(subseurat_1, subseurat_2, num.cc = 30)
			} else if (n_cca > 2) {
				catf("------ Running multi-CCA on %s groups\n", as.character(n_cca))              
				# multi-cca
				cca_list <- vector(mode = "list", length = n_cca)
				names(cca_list) <- names(params$cca)
				for (cca_group in names(params$cca)) {
					# TODO: CCA yaml param should be list of "accept.values" within a "subset.name" for `SubsetData`
					cell_sublist <- params$cca[[cca_group]]
					if (file.exists(cell_sublist)) {
						cell_sublist <- read_lines(cell_sublist)
					} else {
						cell_sublist <- rownames(seurat@meta.data)[seurat@meta.data$group == cca_group]
					}
					subseurat <- SubsetData(seurat,cells.use = cell_sublist,subset.raw=TRUE)
					subseurat <- NormalizeData(subseurat,display.progress = FALSE)
					if (is.null(batch)) {
						subseurat <- ScaleData(subseurat, display.progress = FALSE)
					} else {
						subseurat <- ScaleData(subseurat, display.progress = FALSE, vars.to.regress = batch)
					}
					subseurat_markers <- find_M3Drop_markers(subseurat@data)
					cca_list[[cca_group]] <- subseurat
					# cca_list[[cca_group]]@meta.data$group <- cca_group
					cca_list[[cca_group]]@var.genes <- subseurat_markers$Gene[1:var_genes]
				}
				# cca_genes <- intersect(cca_list[["BAT"]]@var.genes,cca_list[["ING"]]@var.genes)
				# cca_genes <- intersect(cca_genes,cca_list[["EPI"]]@var.genes)
				cca_genes <- unique(unlist(lapply(cca_list,`slot`,"var.genes")))
				# TODO: not hardocde number of CCs?
				seurat <- RunMultiCCA(cca_list, genes.use = cca_genes, num.ccs = 30)
			} else {
				# too few cca dimensions, stop
				catf("----- ERROR: Too few CCA dimensions, skipping")
				next;
			}
			pdf(file.path(var_path, "CCA_plots.pdf"))
			# TODO: loop through features to plot (a la TSNE/UMAP)
			MetageneBicorPlot(seurat, grouping.var = "group", dims.eval = 1:20, display.progress = TRUE)
			DimPlot(seurat, reduction.use = "cca", group.by = "group")
			invisible(dev.off())
			pdf(file.path(var_path, "violin_plots_CCA.pdf"))
			# TODO: loop through CCs (or at least first X, CCs)
			# TODO: change depot to the grouping var
			VlnPlot(seurat, group.by = "group", features.plot = "CC1")
			VlnPlot(seurat, group.by = "group", features.plot = "CC2")
			VlnPlot(seurat, group.by = "group", features.plot = "CC3")
			VlnPlot(seurat, group.by = "group", features.plot = "CC4")
			VlnPlot(seurat, group.by = "group", features.plot = "CC5")
			invisible(dev.off())
			pdf(file.path(var_path, "heatmaps_CCA.pdf"))
			DimHeatmap(seurat, reduction.type = "cca", cells.use = 500,  dim.use = 1:9, do.balanced = TRUE)
			DimHeatmap(seurat, reduction.type = "cca", cells.use = 500,  dim.use = 10:18, do.balanced = TRUE)
			invisible(dev.off())
			
			
			save_seurat(seurat, var_path, raw = TRUE , data = TRUE , scale = TRUE)
            output_stats(
              list("Variable genes" = length(seurat@var.genes)),
              var_path, mito_path
            )

          }

          # Run tSNE and build SNN
          # TODO: allow choice between PCs (PCA) and CCs (CCA)
          for (pc in params$ccs) {
            pc_path <- file.path(var_path, sprintf("PCs_%s", as.character(pc)))

            if (all_exists(pc_path, c("seurat.rds", "tSNE_plots.pdf", "tSNE_plots_M3D.pdf", "UMAP_plots.pdf", "UMAP_plots_M3D.pdf"))) {
              catf("------ %s CCA-selection and tSNE already ran\n", as.character(pc))
            } else {
#               if (pc < 1) {
#                 catf("------ Selecting PCs with cumulative proportion of variance >= %s, running tSNE, building SNN, and plotting marker genes\n", as.character(pc))
#               } else {
#                 catf("------ Selecting %s PCs, running tSNE, running UMAP, and building SNN\n", as.character(pc))
#               }
              seurat <- build_seurat(var_path, raw_data_path = var_path , data_path = var_path , scale_data_path = var_path)

#               # Select PCs
#               if (pc < 1) {
#                 var <- seurat@dr$pca@sdev^2
#                 cum_var <- cumsum(var)/sum(var)
#                 pcs <- 1:which(cum_var >= pc)[1]
#               } else {
#                 pcs <- 1:pc
#               }

              # TODO: Not hardcode CCA dims, use MetageneBicorPlot, etc. to choose appropriate number of CCs
              ccs <- 1:pc
              seurat <- AlignSubspace(seurat, reduction.type = "cca", grouping.var = "group", dims.align = ccs,verbose=FALSE)

              # seurat <- RunTSNE(seurat, dims.use = pcs)
              seurat <- RunTSNE(seurat, reduction.use = "cca.aligned", dims.use = ccs, check_duplicates = FALSE)
              # seurat <- RunUMAP(seurat, dims.use = pcs)
              seurat <- RunUMAP(seurat, reduction.use = "cca.aligned", dims.use = ccs)
              seurat <- BuildSNN(seurat, reduction.type = "cca.aligned", dims.use = ccs, print.output = FALSE)

              # Plot top genes from M3Drop
              make_dir(pc_path)
              markers <- read_tsv(file.path(batch_path, "variable_genes.tsv"), progress = FALSE,
                col_types = cols("Gene" = col_character(), .default = col_double()))
			  catf("-------- Generating tSNE plots (M3D)\n")
              pdf(file.path(pc_path, "tSNE_plots_M3D.pdf"))
#               pc1_loadings <- sort(seurat@dr$pca@gene.loadings[,"PC1"])
#               FeaturePlot(seurat, names(pc1_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, names(pc1_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               pc2_loadings <- sort(seurat@dr$pca@gene.loadings[,"PC2"])
#               FeaturePlot(seurat, names(pc2_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, names(pc2_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               pc3_loadings <- sort(seurat@dr$pca@gene.loadings[,"PC3"])
#               FeaturePlot(seurat, names(pc3_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, names(pc3_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, markers$Gene[1:9], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, markers$Gene[10:18], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              cc1_loadings <- sort(seurat@dr$cca@gene.loadings[,"CC1"])
              FeaturePlot(seurat, names(cc1_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, names(cc1_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              cc2_loadings <- sort(seurat@dr$cca@gene.loadings[,"CC2"])
              FeaturePlot(seurat, names(cc2_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, names(cc2_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              cc3_loadings <- sort(seurat@dr$cca@gene.loadings[,"CC3"])
              FeaturePlot(seurat, names(cc3_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, names(cc3_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, markers$Gene[1:9], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, markers$Gene[10:18], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              invisible(dev.off())
              catf("-------- Generating UMAP plots (M3D)\n")
              pdf(file.path(pc_path, "UMAP_plots_M3D.pdf"))
#               FeaturePlot(seurat, reduction.use = "umap", names(pc1_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, reduction.use = "umap", names(pc1_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, reduction.use = "umap", names(pc2_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, reduction.use = "umap", names(pc2_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, reduction.use = "umap", names(pc3_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, reduction.use = "umap", names(pc3_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, reduction.use = "umap", markers$Gene[1:9], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
#               FeaturePlot(seurat, reduction.use = "umap", markers$Gene[10:18], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, reduction.use = "umap", names(cc1_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, reduction.use = "umap", names(cc1_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, reduction.use = "umap", names(cc2_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, reduction.use = "umap", names(cc2_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, reduction.use = "umap", names(cc3_loadings[1:9]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, reduction.use = "umap", names(cc3_loadings[10:18]), no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, reduction.use = "umap", markers$Gene[1:9], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              FeaturePlot(seurat, reduction.use = "umap", markers$Gene[10:18], no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              invisible(dev.off())

              # Write seurat object and number of PCs used 
              save_seurat(seurat, pc_path)
              output_stats(
#                 list("PCs used" = length(pcs)),
                list("CCs used" = length(ccs)),
                pc_path, var_path
              )
            }

            # Make tSNE plots
            if (
              all_exists(pc_path, c("tSNE_plots.pdf", "tSNE_plots.yml")) &&
              compare_params(params, file.path(pc_path, "tSNE_plots.yml"), c("tsne_plot", "feature_plot"))
            ) {
              cat_time("------- tSNE plots already made\n")
            } else {
              cat_time("------- Making tSNE plots\n")
              seurat <- build_seurat(pc_path, data_path = var_path)

              pdf(file.path(pc_path, "tSNE_plots.pdf"))

              # Default plot
              p <- TSNEPlot(seurat, group.by = "orig.ident", do.return = TRUE, pt.size = params$point_size)
              print(p + ggtitle("Original identity"))

              # User defined categorical plots
              for (feature in params$tsne_plot) {
                feature <- check_features(feature, seurat)
                if (length(feature) == 0) {
                  next
                }
                p <- TSNEPlot(seurat, group.by = feature, do.return = TRUE, pt.size = params$point_size)
                print(p + ggtitle(feature))
              }

              # User defined feature plots
              for (feature in params$feature_plot) {
                feature <- check_features(feature, seurat)
                if (length(feature) == 0) {
                  next
                }
                FeaturePlot(seurat, feature, no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              }

              invisible(dev.off())

              # Save information about what was plotted
              write_yaml(
                list(tsne_plot = params$tsne_plot, feature_plot = params$feature_plot),
                file = file.path(pc_path, "tSNE_plots.yml")
              )
            }
            # Make UMAP plots
            if (
              all_exists(pc_path, c("UMAP_plots.pdf", "UMAP_plots.yml")) &&
              compare_params(params, file.path(pc_path, "UMAP_plots.yml"), c("umap_plot", "feature_plot"))
            ) {
              cat_time("------- UMAP plots already made\n")
            } else {
              cat_time("------- Making UMAP plots\n")
              seurat <- build_seurat(pc_path, data_path = var_path)

              pdf(file.path(pc_path, "UMAP_plots.pdf"))

              # Default plot
              p <- DimPlot(seurat, reduction.use = "umap", group.by = "orig.ident", do.return = TRUE, pt.size = params$point_size)
              print(p + ggtitle("Original identity"))

              # User defined categorical plots
              for (feature in params$umap_plot) {
                feature <- check_features(feature, seurat)
                if (length(feature) == 0) {
                  next
                }
                p <- DimPlot(seurat, reduction.use = "umap", group.by = feature, do.return = TRUE, pt.size = params$point_size)
                print(p + ggtitle(feature))
              }

              # User defined feature plots
              for (feature in params$feature_plot) {
                feature <- check_features(feature, seurat)
                if (length(feature) == 0) {
                  next
                }
                FeaturePlot(seurat, reduction.use = "umap", feature, no.legend = TRUE, cols.use = c("grey", "blue"), pt.size = params$point_size)
              }

              invisible(dev.off())

              # Save information about what was plotted
              write_yaml(
                list(umap_plot = params$umap_plot, feature_plot = params$feature_plot),
                file = file.path(pc_path, "UMAP_plots.yml")
              )
            }

            # Run clustering
            for (res in params$resolution) {
              res_path <- file.path(pc_path, sprintf("res_%s", as.character(res)))

              if (all_exists(res_path, c("seurat.rds", "dot_plots_M3D.pdf", "cluster_plots_tSNE.pdf",  "cluster_plots_UMAP.pdf"))) {
                catf("-------- Clustering with res %s already ran\n", as.character(res))
              } else {
                catf("-------- Finding clusters with resolution %s\n", as.character(res))
                seurat <- build_seurat(pc_path, data_path = var_path)

                # Load number of PCs
#                 pcs <- 1:yaml.load_file(file.path(pc_path, "stats.yml"))$`PCs used`

                # g <- capture.output(seurat <- FindClusters(seurat, resolution = res, reuse.SNN = TRUE, print.output = FALSE))
                g <- capture.output(seurat <- FindClusters(seurat, resolution = res, reuse.SNN = TRUE, reduction.type = "cca.aligned", print.output = FALSE))
                # seurat <- BuildClusterTree(seurat, pcs.use =  pcs, do.reorder = TRUE, reorder.numeric = TRUE, do.plot = FALSE, show.progress = FALSE)
                seurat <- BuildClusterTree(seurat, do.reorder = TRUE, reorder.numeric = TRUE, do.plot = FALSE, show.progress = TRUE)

                # Write seurat object and number of clusters found 
                make_dir(res_path)
                save_seurat(seurat, res_path)
                output_stats(
                  list("Clusters" = length(levels(seurat@ident))),
                  res_path, pc_path
                )

                # Plot clusters and cluster tree
                pdf(file.path(res_path, "cluster_plots_tSNE.pdf"))
                p <- TSNEPlot(seurat, do.return = TRUE, do.label = TRUE, pt.size = params$point_size)
                print(p + ggtitle(sprintf("Clusters with resolution %s", as.character(res))))
                PlotClusterTree(seurat)
                title(sprintf("Cluster tree with resolution %s", res))
                invisible(dev.off())
                pdf(file.path(res_path, "cluster_plots_UMAP.pdf"))
                p <- DimPlot(seurat, reduction.use = "umap", do.return = TRUE, do.label = TRUE, pt.size = params$point_size)
                print(p + ggtitle(sprintf("Clusters with resolution %s", as.character(res))))
                PlotClusterTree(seurat)
                title(sprintf("Cluster tree with resolution %s", res))
                invisible(dev.off())

                # Plot top genes from M3Drop
                markers <- read_tsv(file.path(batch_path, "variable_genes.tsv"), progress = FALSE,
                  col_types = cols("Gene" = col_character(), .default = col_double()))
                pdf(file.path(res_path, "dot_plots_M3D.pdf"))
                # TSNEPlot(seurat, do.label = TRUE, pt.size = params$point_size)
#                 if (using_provided_variable_genes_list) {
                  # pc1_loadings <- sort(seurat@dr$pca@gene.loadings[,"PC1"])
                  # make_dot_plots(seurat, names(pc1_loadings[1:9]))
                  # make_dot_plots(seurat, names(pc1_loadings[10:18]))
                  # pc2_loadings <- sort(seurat@dr$pca@gene.loadings[,"PC2"])
                  # make_dot_plots(seurat, names(pc2_loadings[1:9]))
                  # make_dot_plots(seurat, names(pc2_loadings[10:18]))
                  # pc3_loadings <- sort(seurat@dr$pca@gene.loadings[,"PC3"])
                  # make_dot_plots(seurat, names(pc3_loadings[1:9]))
                  # make_dot_plots(seurat, names(pc3_loadings[10:18]))
#                 } else {
                  # make_dot_plots(seurat, markers$Gene[1:9])
                  # make_dot_plots(seurat, markers$Gene[10:18])
#                 }
                invisible(dev.off())
				TSNEPlot(seurat, do.label = TRUE, pt.size = params$point_size)
				cc1_loadings <- sort(seurat@dr$cca@gene.loadings[,"CC1"])
				make_dot_plots(seurat, names(cc1_loadings[1:9]))
				make_dot_plots(seurat, names(cc1_loadings[10:18]))
				cc2_loadings <- sort(seurat@dr$cca@gene.loadings[,"CC2"])
				make_dot_plots(seurat, names(cc2_loadings[1:9]))
				make_dot_plots(seurat, names(cc2_loadings[10:18]))
				cc3_loadings <- sort(seurat@dr$cca@gene.loadings[,"CC3"])
				make_dot_plots(seurat, names(cc3_loadings[1:9]))
				make_dot_plots(seurat, names(cc3_loadings[10:18]))
				make_dot_plots(seurat, markers$Gene[1:9])
				make_dot_plots(seurat, markers$Gene[10:18])
				invisible(dev.off())

                # Link data
                file.symlink("../../../../../../raw_data.rds", res_path)
                file.symlink("../../../../data.rds", res_path)
                file.symlink("../../../scale_data.rds", res_path)
                file.symlink("../../../variable_genes.tsv", res_path)
                file.symlink("../../pc_loadings.tsv", res_path)
                file.symlink("../../pc_variation.pdf", res_path)
                file.symlink("../../CCA_plots.pdf", res_path)
                file.symlink("../../violin_plots_CCA.pdf", res_path)
                file.symlink("../tSNE_plots_M3D.pdf", res_path)
                file.symlink("../tSNE_plots.pdf", res_path)
                file.symlink("../UMAP_plots_M3D.pdf", res_path)
                file.symlink("../UMAP_plots.pdf", res_path)
                file.copy("session_info.txt", res_path)

                # Link data from top level
                make_dir("links")
                file.symlink(file.path("..", res_path), file.path("links", gsub("/", "-", res_path)))
              }

              # Make violin plots
              if (
                all_exists(res_path, c("violin_plots.pdf", "violin_plots.yml")) &&
                compare_params(params, file.path(res_path, "violin_plots.yml"), "violin_plot")
              ) {
                cat_time("--------- Violin plots already generated\n")
              } else {
                cat_time("--------- Making violin plots\n")
                seurat <- build_seurat(res_path, data_path = var_path)

                pdf(file.path(res_path, "violin_plots.pdf"))
 
                # Make standard violin plots
                print(VlnPlot(seurat, "percent.mito", point.size.use = params$point_size))
                print(VlnPlot(seurat, "nUMI", y.log = TRUE, point.size.use = params$point_size))
                print(VlnPlot(seurat, "nGene", y.log = TRUE, point.size.use = params$point_size))

                # Make user defined violin plots
                for (feature in params$violin_plot) {
                  feature <- check_features(feature, seurat)
                  if (length(feature) == 0) {
                    next
                  }
                  print(VlnPlot(seurat, feature, point.size.use = params$point_size))
                }

                invisible(dev.off())

                # Save information about what was plotted
                write_yaml(
                  list(violin_plot = params$violin_plot),
                  file.path(res_path, "violin_plots.yml")
                )
              }

              # Make dot plots
              if (
                all_exists(res_path, c("dot_plots.pdf", "dot_plots.yml")) &&
                compare_params(params, file.path(res_path, "dot_plots.yml"), "dot_plot")  
              ) {
                cat_time("--------- Dot plots already generated\n")
              } else {
                cat_time("--------- Making dot plots\n")
                seurat <- build_seurat(res_path, data_path = var_path)
                
                pdf(file.path(res_path, "dot_plots.pdf"))
                TSNEPlot(seurat, do.label = TRUE, pt.size = params$point_size)
                for (feature in params$dot_plot) {
                  feature <- check_features(feature, seurat)
                  if (length(feature) == 0) {
                    next
                  }
                  make_dot_plots(seurat, feature)
                }
                invisible(dev.off())

                # Save information about what was plotted
                write_yaml(
                  list(dot_plot = params$dot_plot),
                  file.path(res_path, "dot_plots.yml")
                )
              }
            }
          }
        }
      }
    }
  }
}
