#! /usr/bin/env perl
#
# Demultiplex sequencing data sets.

=head1 NAME

demultiplex.pl - Demultiplex (Illumina) sequencing data sets.

=head1 SYNOPSIS

	# demultiplex the current working directory (using defaults _only_)
	demultiplex.pl [<options>]
	demultiplex.pl [<options>] --mask='Y36,I8,Y36'
	demultiplex.pl [<options>] --only='RNA-Seq'
	
	# demultiplex target (run directory)
	demultiplex.pl [<options>] <target>+
	demultiplex.pl [<options>] --mask='Y36,I8,Y36' <target>+
	demultiplex.pl [<options>] --only='ChIP-Seq' <target>+

=head1 DESCRIPTION

Demultiplex raw sequencing data. This program is currently designed to work only
with the sequencing run folders generated by next-gen Illumina sequencers, in
tandem with the L<F<bcl2fastq>|https://support.illumina.com/sequencing/sequencing_software/bcl2fastq-conversion-software.html>
program provided by Illumina. The version of this command, as well as a list of
all the default options provided to it by this script, can be seen by specifying
the L<C<--version>> option (see the linked option description for more details).
 
The default behavior of the demultiplexing command that gets called by this
program may be modified or supplemented by providing additional options (via the
C<--options> option). Note that if is this option is specified, B<none> of the
default options are used. This behavior is designed to prevent -- as much as is
possible -- mutually exclusive options from being provided. If you are certain
that your options will not clash with the default option set, you may specify
the option C<--with-defaults>:

	demultiplex.pl --options="--ignore-missing-controls" --with-defaults <target>

Be aware that any options passed to this script will be applied to B<all> of the
specificed C<< <target> >>s. Be careful that this is your intent.

Although not recommended, demultiplexing non-Illumina sequence data (or very old
Illumina data) is also possible by specifying both the C<--command> option and
the C<--options> option (you'll probably need to specify the C<--library-path>
as well):

	demultiplex.pl --command='bash5tools.py' --options="--outType='fastq'" --library-path="system/appropriate/path(s)" <target>+

The C<--options-file> option may come in useful here. It will read options from
the specified file (see below for details). The same caveats apply when using
the C<--options-file> option as when using the C<--options> option.

=head2 bcl2fastq and other demultiplexing commands

Note that this file provides neither F<bcl2fastq> nor any other demultiplexing
software. It only provides a "wrapper" for these programs in order to streamline
the most common usage(s) --- and to a limited extent, standardize some of their
behavior(s).

Whenever F<bcl2fastq> or any other provided command is invoked by this script,
standard shell procedure for calling commands is used, i.e. the first instance
of the full command name found in the user's C<ENV{PATH}> will be executed.

=cut

# script-level stuff
our $VERSION = v0.8.2;

# pragmas
use 5.020;
use utf8;
use strict;
use warnings; use warnings qw< FATAL utf8 >; use warnings::register;
use open qw < :std :utf8 >;
use experimental qw< signatures postderef >;

# core modules
use Cwd qw< getcwd >;
use English;
use Encode qw < encode decode >;
use File::Basename qw< basename fileparse >;
use File::Glob qw< :bsd_glob >;
use File::Spec::Functions qw< catdir catfile >;
use File::Temp qw< tempdir tempfile >;
use Getopt::Long qw< GetOptionsFromString HelpMessage VersionMessage >;
use Pod::Usage qw< pod2usage >;
use Text::ParseWords;
use Unicode::Collate;

# cpan modules
use File::Which qw< which >;
use IPC::Run qw< run >;
use Lingua::EN::Numbers qw< num2en >;
use List::AllUtils qw< none pairmap reduce >;
use Scalar::MoreUtils qw< define >;
use XML::LibXML;

# custom modules
use RosenLab;
use RosenLab::Log::Simple;

=begin comment CONSTANTS

=begin comment

INFO: These constants aren't really relevant to usage. They are documented
within this comment section (albeit still in POD format) so that editors of this
file may benefit from their description.

NOTE: constants defined within a block cannot reference one another, hence the
splitting of some constants into separate declarations (in order to reduce the
amount of easy errors made by altering these values);

=end comment

=head2 Demultiplexing defaults

=over

=item DEFAULT_COMMAND

The absolute path to the default demultiplexing system command.

=item DEFAULT_LIBPATH

A list of extra directories (as absolute paths) to provide the shared library
loader.

=back

=head3 F<bcl2fastq> defaults

=over

=item DEFAULT_BCL2FASTQ_CMD

The absolute path to the `bcl2fastq` command to be used by default.

=item DEFAULT_BCL2FASTQ_OPT

The default options to supply to the `bcl2fastq` command to be used by default.
These options will undergo a form of variable "interpolation" before being
used (e..g. the substring C<${target}> will be substituted for the value of the
C<< <target> >> command line argument).

=item DEFAULT_BCL2FASTQ_LIB

The default library path to include for the `bcl2fastq` command.

=back

=end comment

=cut

# bcl2fastq defaults
use constant
	{
		DEFAULT_BCL2FASTQ_VERSION => '2.20.0',
	};
use constant
	{
		DEFAULT_BCL2FASTQ_HOME => catdir(RosenLab::SOFTWARE_REPOSITORY,
			"bcl2fastq2-" . DEFAULT_BCL2FASTQ_VERSION),
	};
use constant
	{
		DEFAULT_BCL2FASTQ_CMD => catfile(DEFAULT_BCL2FASTQ_HOME,'bin','bcl2fastq'),
		DEFAULT_BCL2FASTQ_OPT =>
			[
				# bcl2fastq general options
				{'--min-log-level','DEBUG'},
				# bcl2fastq main options
				{'--runfolder-dir','${target}'},
				{'--output-dir',catdir('${target}','${output-folder}${suffix}')},
				# bcl2fastq directory options
				{'--sample-sheet','SampleSheet${suffix}.csv'},
				# bcl2fastq processing options
				{'--loading-threads',4},
				# {'--demultiplexing-threads',4}, # NOTE: removed in bcl2fastq version 2.19.0 (undocumented change)
				{'--processing-threads',4},
				{'--writing-threads',4},
				# bcl2fastq behavioral options
				'--ignore-missing-bcls',
				'--ignore-missing-filter',
				'--ignore-missing-positions',
				# '--ignore-missing-controls', # NOTE: removed in bcl2fastq version 2.19.0
				{'--minimum-trimmed-read-length',20},
 				{'--mask-short-adapter-reads',15},
				{'--barcode-mismatches',1},
				{'--use-bases-mask','${mask}'},
				'--no-lane-splitting',
			],
		DEFAULT_BCL2FASTQ_LIB =>
			[
			],
	};

# script defaults
use constant
	{
		# input/output
		DEFAULT_LOG_FILE_NAME => '',
		DEFAULT_DEMUX_LOG_NAME => '',
		DEFAULT_COUNTS_FILE_NAME => '',
		# demultiplexing
		DEFAULT_COMMAND => DEFAULT_BCL2FASTQ_CMD,
		DEFAULT_OPTIONS => DEFAULT_BCL2FASTQ_OPT,
		DEFAULT_LIBPATH => join(':',DEFAULT_BCL2FASTQ_LIB->@*), # TODO: should try to be platform agnostic
		# miscellaneous
		DEFAULT_DATA_DIR => RosenLab::SEQUENCING_DATA_REPOSITORY,
		DEFAULT_OUTPUT_DIR => 'FASTQ',
	};

=head1 OPTIONS

Options are specified as though they were passed to a POSIX-compliant script.
That is, short-form options may be bundled together (e.g. C<-vv>), and long-form
options must be proceeded with two dashes (C<-->) without whitespace separation.
The special option C<--> (alone) specifies that no further options will be
parsed beyond its occurence. Note that for all of these options the short-form
must not include a literal '=' between the option name and the option argument
(if any). The literal '=' is optional, but recommended, for long-form options.

The following options may be provided to this script:

=head2 General program options

=over

=item X<--help>--help, -h

Prints a help message and exits. If this option is specified no other action
will be taken by this program (i.e. the commands will be effectively ignored).
Only the first of either this option or C<--version> is processed.

=item X<--version>--version

Prints the program version number (and a few other version numbers which may be
relevant to the user) and exits. If this option is specified no other action
will be taken by this program (i.e. the commands will be effectively ignored).
Only the first of either this option or C<--version> is processed.

=item X<--verbose>--verbose, -v

Increments the verbosity level related to log messages by one (C<1>). The
default log level (C<0>) logs only error messages (which may or may not be
fatal). Specify this option multiple times to increase the verbosity to any
desired level (max: C<3>).

=item X<--quiet>--quiet

Resets the verbosity level to the default value (C<0>). If multiple C<--verbose>
and/or C<--quiet> options are specified, they are processed in order.

=back

=head2 Script-level control options

=over

=item X<--print>--print, -p

Display what commands (with their arguments) would be run, but don't actually
execute any of those commands. This command will override L<C<--force>>.

=item X<--force>--force, -f

Force processes to execute through warnings and non-fatal errors.

=item X<--all>--all, -a

B<DEPRECATED>. Please do not use this option. Prefer instead to execute this
script multiple times with different L<C<--only>> flags.

Demultiplex for all subsets of data. Data subsets are taken as filename suffices
(preceding the filename extension) to any sample sheets found in the target.
This should only happen in the rarae occurence that a flow-cell was split
between incompatible libraries (e.g. different adapter/indexing read lengths).

=item X<--only>--only=<name>

Demultiplex only a subset of data based on the provided name.

This option is (currently) only intended to work when the assumptions about the
structure of the target directory are satisfied (generated by an Illumina
next-gen sequencer, etc.; see L</DESCRIPTION> above).

=back

=head2 I/O control options

=over

=item X<--log-file>--log-file=<file>

The log file for this program. By default, errors and warnings are written to
STDERR, while messages (debug, etc) are written to STDOUT. Specifying a log file
will redirect all logging messages to the file, regardless of thier severity or
verbosity level.

=item X<--demux-log>--demux-log=<file>

The log file for the demultiplexing command. The F<bcl2fastq> command defaults
to writing this information to STDERR.

=item X<--counts-file>--counts-file=<file>

Where to put the barcode counts file. This file summarizes the barcode count
information that is produced by the demultiplexing command. Defaults to STDOUT.

=back

=head2 Command control options

=over

=item X<--command>--command=<command>, -C <command>

Uses this command instead of the default F<bcl2fastq> command to demultiplex.
This implies L<C<--no-defaults>>. You will almost certainly need to set the
L<C<--library-path>> option as well.

If you are using this command to run F<bcl2fastq> from a non-standard location
(perhaps a specific version), remember that by specifying this option, the
default options list will be empty. You can override this behavior by specifying
the additional option: C<--with-defaults>. You will _probably_ need to set the
L<C<--library-path>> option in this case as well.

=item X<--library-path>--library-path=<path>, -L <path>

Supercedes the library path normally searched by the dynamic linker (loader).

=item X<--options>--options=<options>, -O <options>

Supercede the default command options with these. If the L<C<--command>> option
is specified, then  C<---options=''> is implied unless it is provided.

=item X<--options-file>--options-file=<file>, -F <file>

WARNING: This option is not yet properly implemented. Please do not use it.

Provide command options, as per L<C<--options>>, but parsed from a file rather
than from the provided argument. Useful for long option strings, or option
strings contain quotes and/or spaces (or any other unusual characters that can
be difficult to properly pass via command line).

TODO: implement properly

=item X<--with-defaults>--with-defaults

Pass the default F<bcl2fastq> options to the demultiplexing command, even if
additional options are specified. Note that if multiple L<C<--with-defaults>>
and L<C<--no-defaults>> options are specified, the last occurence will take
precendence.

=item X<--no-defaults>--no-defaults

Do not pass any of the default options to the demultiplexing command, even if
no additional options are specified. Note that if multiple L<C<--no-defaults>>
and L<C<--with-defaults>> options are specified, the last occurence will take
precendence.

=back

=head2 Other options

=over

=item X<--data-repository>--data-repository, -D

The default location to look for C<< <target> >>s, when they are not absolute
paths. This is mostly useful when specifying multiple C<< <target> >>s that
reside in a non-standard data repository. By default this value is set to use
the location C<RosenLab::SEQUENCING_DATA_REPOSITORY> provided by the F<RosenLab>
distribution.

=back

=cut

# option-related variables
my %_options =
	(
		# general options
		'help' => 0,
		'version' => 0,
		# script-level control
		'force' => 0,
		'print' => 0,
		# input/output control
		'log-file' => DEFAULT_LOG_FILE_NAME,
		'demux-log' => DEFAULT_DEMUX_LOG_NAME,
		'counts-file' => DEFAULT_COUNTS_FILE_NAME,
		# data subsetting
		'all' => 0,
		'only' => '',
		# other options
		'data-repository' => DEFAULT_DATA_DIR,
	);
my %_demultiplex =
	(
		'command' => DEFAULT_COMMAND, # demultiplexing command
		'options' => # command options
			{
				'default' => DEFAULT_OPTIONS,
				'custom' => undef,
			},
		'libpath' => DEFAULT_LIBPATH, # path containing required shared objects
	);
local $RosenLab::Log::Simple::verbosity = 0;

# allow options to be bundled and stop processing after `--`.
my $option_parser = Getopt::Long::Parser->new();
$option_parser->configure('bundling','require_order');

# parse options from script arguments
{
	my @noptions = ();
	# catch the unknown options warnings and turn into (logged) errors
	local $SIG{__WARN__} = sub ( $message )
		{
			chomp($message);
			if ($message =~ m(^Unknown option: (?<option>\S+)$))
			{
				# message is about an unknown options
				my $option = $LAST_PAREN_MATCH{'option'};
				error("Encountered unknown <option>: ${option}");
				push(@noptions,$option);
			}
			elsif ($message =~ m(^Option (?<option>\S+) requires an argument$))
			{
				# warning is about missing option argument
				my $option = $LAST_PAREN_MATCH{'option'};
				error("Missing required argument for <option>: ${option}");
				push(@noptions,$option);
			}
			elsif ($message =~ m(^Value "(?<value>\S+)" invalid for option (?<option>\S+)))
			{
				# warning is about invalid option argument
				my $option = $LAST_PAREN_MATCH{'option'};
				error("Invalid argument for <option>: ${option}");
				push(@noptions,$option);
			}
			else
			{
				fatal("Could not parse options: ${message}")
			}
		};
	# set help/version options
	sub _set_special_option ( $id , $value )
	{
		return if ($_options{'help'} || $_options{'version'});
		$_options{$id} = 1;
	}
	# set logs
	sub _set_log ( $log , $filename )
	{
		$_options{$log} = _open_file_handle($filename);
	}
	# get the options
	$option_parser->getoptions
		(
			# general options
			'help|h|?' => \&_set_special_option,
			'version|V' => \&_set_special_option,
			'verbose|v+' => \$RosenLab::Log::Simple::verbosity,
			'quiet' => sub { $RosenLab::Log::Simple::verbosity = 0; },
			# script-level control options
			'force|f' => \$_options{'force'},
			'print|p' => \$_options{'print'},
			# input/output control
			'log-file=s' => \$_options{'log-file'},
			'counts-file=s' => \$_options{'counts-file'},
			'demux-log=s' => \$_options{'demux-log'},
			# command-level control options
			'command|C=s' => \$_demultiplex{'command'},
			'options|O=s' => \$_demultiplex{'options'}{'custom'},
			'library-path|L=s' => \$_options{'libpath'},
			'with-defaults' => sub { $_demultiplex{'defaults'} = 'with' },
			'no-defaults' => sub { $_demultiplex{'defaults'} = 'no' },
			'mask=s' => \$_options{'mask'},
			# data subsetting
			'all|a' => \$_options{'all'},
			'only=s' => \$_options{'only'},
		) or fatal("Errors parsing <options>: @noptions");
}

# special option handling for help/version
_version() if ($_options{'version'});
_help() if ($_options{'help'});

# set up logging
my $log_main = $_options{'log-file'}
	? _open_file_handle($_options{'log-file'})
	: *STDERR;
binmode($log_main,':encoding(UTF-8)');
local $RosenLab::Log::Simple::error_fh = $log_main;
local $RosenLab::Log::Simple::output_fh = $log_main;
my $log_demux = $_options{'demux-log'}
	? _open_file_handle($_options{'demux-log'})
	: *STDERR;
binmode($log_demux,':encoding(UTF-8)');

=begin comment MAIN

INFO: These section isn't relevant to usage. This POD comment is included solely
for the purposes of delimiting the "main" script from the other sections.

=end comment

=cut

# unicode text comparison helper(s)
my $comparator = Unicode::Collate->new();
my $matcher = Unicode::Collate->new( normalization => undef, level => 1 );
	
# build the demultiplexing command (and library path)
my $command = $comparator->ne($_demultiplex{'command'},DEFAULT_COMMAND)
	? _build_command()
	: $_demultiplex{'command'};
_build_libpath($command);

# put the default target into the target list if no targets are specified
push(@ARGV,getcwd()) unless (@ARGV);

while (my $argument = shift(@ARGV))
{
	message("Processing <target>: $argument");
	# find the target
	my $target = _find_target(decode('UTF-8',$argument));
	unless (defined($target))
	{
		message("Skipping invalid <target>: $argument");
		next;
	}
	my @suffices = $_options{'all'}
		? map
			{
				s(SampleSheet(?:_(\S*))\.csv)($1);
				basename($_);
			} bsd_glob(catfile(${target},"SampleSheet*.csv"))
		: $_options{'only'}
			? ($_options{'only'})
			: (''); # single empty suffix
	for my $suffix (@suffices)
	{
		# build the demultiplexing options
		my @options = _build_options($target,$suffix);
		# run demultiplexing
		demultiplex($target,$command,\@options);
		# generate demultiplexing statistics file(s)
		statestify(catdir($target,'FASTQ')); # TODO: fix this to find the otuput firectory (don't assume "$target/FASTQ").
	}
}

# goodbye
exit(0);

=begin comment head1 SUBROUTINES

INFO: The specifics of these subroutines aren't really relevant to usage. They
are documented within this comment section (albeit still in POD format) so that
editors of this file may benefit from their description.

=end comment

=cut

sub demultiplex ( $target , $command = $_demultiplex{'command'} , $options  = $_demultiplex{'options'}{'default'}  )
{
	# demultiplex
	message("Demultiplexing: $target");
	if ($_options{'print'})
	{
		debug("Displaying demultiplexing system call: $command $options->@*");
# 		say $_options{'demux-log'} "$command $options->@*";
		say $log_demux "$command $options->@*";
		return;
	}
	debug("Executing system call: $command $options->@*");
	message("$command $options->@*");
# 	run([$command,$options->@*],'>',$_options{'demux-log'});
	run([$command,$options->@*],'>',$log_demux);
}

sub statestify ( $target )
{
	message("Generating demultiplexing statistics: $target");
	_generate_counts_file($target);
}

=begin comment head2 Option-related subroutines

Subroutines for executing special option-related tasks (display help/version,
opening log files, etc.).

=end comment

=cut

=begin comment head3 _help

Print a help message and exits.

=end comment

=cut

sub _help ()
{
	pod2usage(
		{
			'-exitval' => 0,
			'-verbose' => $RosenLab::Log::Simple::verbosity,
		});
}

=begin comment head3 _version

Print the version of this script -- plus the versions of any commands it calls
-- and exits.

=end comment

=cut

sub _version ()
{
	# script version
	my $script = fileparse(__FILE__);
	my $version = sprintf("%s version %vd (Perl version %vd)\n",$script,$VERSION,$^V);
	# module versions TODO
	if ($RosenLab::Log::Simple::verbosity >= 1)
	{
		$version .= sprintf("Module version(s):\n");
	}
	# bcl2fastq version
	$version .= sprintf("Command version(s):\n");
	$ENV{'LD_LIBRARY_PATH'} = $_options{'libpath'} // DEFAULT_LIBPATH;
	foreach my $line (qx($_demultiplex{'command'} --version 2>&1))
	{
		chomp($line);
		if ( $line =~ m( .* (?:v(?:ersion)?\s*) (?::\s*)? (?<version>(?:\d\.?)+) .* )x )
		{
			my $command = fileparse($_demultiplex{'command'});
			$version .= sprintf("\t%s version %s",$command,$LAST_PAREN_MATCH{'version'});
			last;
		}
	}
	say "$version";
	exit(0);
}

=begin comment head3 _open_file_handle

Opens a file for logging. This function is used to open several files, not just
those enabled by the C<--log-file> option.

=end comment

=cut

sub _open_file_handle ( $filename )
{
	warning("File already exists (appending): $filename")
		if (-f $filename);
	return IO::File->new($filename,'>>');
}

=begin comment head2 Command-related subroutines

Subroutines for controlling the behavior of the demultiplexing command.

=end comment

=cut

=begin comment head3 _build_command

Build the demultiplexing command (take from input). Also clear the command's
options list (removes the default options).

=end comment

=cut

sub _build_command ()
{
	debug("Building <command>...");
	# defaul command: don't build anything
	my $command = $_demultiplex{'command'};
	return $command
		unless ($comparator->ne($command,DEFAULT_COMMAND));
	# test that command is discoverable and executable
	debug("Testing <command> is an executable on path: $command");
	my $path = which($command);
	fatal("Invalid <command> specified: $command") unless ($path);
	# update command path
	debug("Setting <command> to: $path");
	$command = $path;
	# clear the default options from the options list
# 	_build_libpath($command);
	_remove_default_command_options();
	return $command;
}

=begin comment head3 _build_libpath

Build the demultiplexing command shared object path.

=end comment

=cut

sub _build_libpath ( $command , $paths = $_demultiplex{'libpath'} )
{
	debug("Building <library-path>...");
	debug("Setting LD_LIBRARY_PATH to: $paths");
	$ENV{'LD_LIBRARY_PATH'} = $paths;
	_validate_libpath($command);
}

=begin comment head3 _validate_libpath

Check the demultiplexing command dependencies. This makes sure the the dynamic
linker (loader) is able to discover all the correct shared objects the command
depends on.

=end comment

=cut

sub _validate_libpath ( $command = $_demultiplex{'command'} )
{
	debug("Validating <library-path>...");
	my $ldd = which('ldd');
	unless (defined $ldd)
	{
		error("Could not verify <command> shared library dependencies: `ldd` not found.");
		return;
	}
	my ($out_fh,$out_file) = tempfile(UNLINK => 1);
	my ($err_fh,$err_file) = tempfile(UNLINK => 1);
	system("ldd $command 1>${out_file} 2>${err_file}");
	my @errors = <$err_fh>;
	return unless (@errors);
	fatal("Missing required libraries: `ldd $command` for more details.");
}

=begin comment head3 _build_options

Build the demultiplexing command options. Start with the command's current
options list, add/clear the default options, by request, then push all options
specified as C<< <command-options> >>.

=end comment

=cut

sub _build_options ( $target , $suffix = '' )
{
	debug("Building <command-options>...");
	# `--comand=<command>` was specified; default options were removed
	if ($comparator->ne($_demultiplex{'command'},DEFAULT_BCL2FASTQ_CMD))
	{
		# add them back if asked to by `--with-defaults`
		_add_default_command_options() if (define($_demultiplex{'defaults'}) eq 'with');
	}
	# otherwise: remove the default options if alternative options were specified
	# (unless `--with-defaults` was also specified) or if `--no-defaults` was specified
	elsif ((define($_demultiplex{'defaults'}) eq 'no') ||
		(defined($_demultiplex{'options'}{'custom'})) && (define($_demultiplex{'defaults'}) ne 'with'))
	{
		_remove_default_command_options();
	}
	my @options = $_demultiplex{'options'}{'default'}->@*;
	# parse the RunInfo.xml file for default option values
	my %defaults = _parse_runinfo($target);
	$defaults{'target'} = $target;
	$defaults{'output-folder'} = DEFAULT_OUTPUT_DIR;
	$defaults{'suffix'} = ${suffix}
		? '_' . ${suffix}
		: '';
	# after the default options are added (or not), append the alternative command options
	if ($_demultiplex{'options'}{'custom'})
	{
		debug("Adding custom options to <command-options>...");
		push(@options,Text::ParseWords::shellwords($_demultiplex{'options'}{'custom'}))
	}
	# flatten and return the options list
	return _finalize_options(\@options,\%defaults);
}

=begin comment head3 _finalize_options

Finalize an options list. This involves a few things:

=over

=item Flattening

Option lists use arrays to group options names with their arguments, this
flattens such options into the top-level list such that they may be passed to
the system call as a single argument list. For example:

	# prints: "mycmd -X -y -z --long1=arg1 --long2=arg2 parameter"
	$opt = ['-X','-y','-z',['--long1','arg1'],['--long2',arg2']];
	@opt = _finalize_options($opt);
	print "mycmd @opt parameter";

=item 'Interpolating'

This allows for the interpolation of a few select options into an option list.
Only those select few variables are interpolated at this stage.

=back

=end comment

=cut

sub _finalize_options  ( $array , $interpolations )
{
	# TODO: `use Perl6::Feeds` could be useful here...
	unless (none { ref($_) eq 'HASH'; } $array->@*)
	{
		$array->@* = map
			{
				# flatten long option pairs into '--option=argument'
				ref($_) eq 'HASH' ? pairmap { join('=',$a,$b); } $_->%* : $_;
			} $array->@* while grep
				{
					ref($_) eq 'HASH';
				} $array->@*;
	}
	return $array->@* = map
		{
			# "interpolate"
			pairmap { s(\$\{$a\})($b); } $interpolations->%*;
			$_;
		} $array->@*;
}

sub _add_default_command_options ()
{
	debug("Adding defaults to <command-options>.");
	$_demultiplex{'options'}{'default'} = DEFAULT_BCL2FASTQ_OPT;
}

sub _remove_default_command_options ()
{
	debug("Clearing defaults from <command-options>.");
	$_demultiplex{'options'}{'default'} = [];
}

=begin comment head2 Report-related subroutines

Subroutines for generating reports/statistics files.

=end comment

=cut

sub _generate_counts_file ( $fastq_dir )
{
	debug("Generating counts file...");
	# find the file
	my $path = catfile($fastq_dir,'Stats','DemultiplexingStats.xml');
	return unless ((-f $path) && (-r $path));
	# parse the file for samples
	debug("Parsing demultiplexing stats file: $path");
	my $xml = XML::LibXML->load_xml(location => $path);
	my @samples = grep
		{
			$comparator->ne($_->{name},'Undetermined')
				&& $comparator->ne($_->{name},'all')
					&& ($matcher->index($_->{name},'discard') != 0);
		} $xml->findnodes('/Stats/Flowcell/Project/Sample');
	# parse each sample record for the barcode counts
	my %records = ();
	my $header = undef;
	foreach my $sample (@samples)
	{
		my @lanes = $sample->findnodes('Barcode[@name="all"]/Lane');
		debug("Parsing barcode counts (total) for sample: $sample->{name}");
		my %counts = map
			{
				$_->{number} => $_->findvalue('BarcodeCount');
			} @lanes;
		my @values = @counts{sort(keys(%counts))};
		$records{$sample->{name}} = join("\t" , @values , reduce { $a + $b } @values);
		debug("Parsing barcode counts (mismatch=0) for sample: $sample->{name}");
		%counts = map
			{
				$_->{number} => $_->findvalue('PerfectBarcodeCount');
			} @lanes;
		@values = @counts{sort(keys(%counts))};
		$records{$sample->{name}} = join("\t" ,
			$records{$sample->{name}} , @values , reduce { $a + $b } @values);
		foreach my $mismatches (1..10)
		{
			my $name = sprintf('%sMismatchBarcodeCount',
				ucfirst(num2en($mismatches)));
			last unless $lanes[0]->findvalue($name);
			debug(sprintf('Parsing barcode counts (mismatch=%d) for sample: %s',
				$mismatches,$sample->{name}));
			%counts = map
				{
					$_->{number} => $_->findvalue($name);
				} @lanes;
			@values = @counts{sort(keys(%counts))};
			$records{$sample->{name}} = join("\t" ,
				$records{$sample->{name}} , @values , reduce { $a + $b } @values);
		}
		# populate the header line (but only do this once)
		next if defined($header);
		$header = join("\t",'Sample Name',
			map({ sprintf('Barcodes (total: lane %d)',$_) } 1..($#lanes+1) ),
			'Barcodes (total)',
			map({ sprintf('Barcodes (mismatch=0: lane %d)',$_) } 1..($#lanes+1) ),
			'Barcodes (mismatch=0)',
			map({}));
	}
	# print the counts file
	say "$header";
	say join("\t",$_,$records{$_}) foreach (sort keys %records);
}

=begin comment head2 Other (miscellaneous) subroutines

Subroutines for controlling the behavior of the demultiplexing command.

=end comment

=cut

=begin comment head3 _find_target

Discover the demultiplexing C<< <target> >>. This subroutine first tries to use
C<< <target> >> as a path to the run directory. If that fails, attempts to build
such a path using C<< <target> >> as the basename of a run directory within
L<C<DEFAULT_BCL2FASTQ_DATA_DIR>>.

=end comment

=cut

sub _find_target ( $name )
{
	debug("Discovering <target>...");
	# try the given target as an aboslute path
	debug("Trying <target> as relative path to run directory: $name");
	return $name if (-d $name);
	# try the target as the name of run directory
	my $target = catdir(DEFAULT_DATA_DIR,$name);
	debug("Trying <target> as run directory name in default location: $target");
	return $target if (-d $target);
	error("Invalid <target> specified: $name");
	return undef;
}

=begin comment head3 _parse_runinfo

Parse the F<RunInfo.xml> file in the target directory for some option values.

=end comment

=cut

sub _parse_runinfo ( $target )
{
	# find the file
	debug("Discovering run information file...");
	my $path = catfile($target,'RunInfo.xml');
	unless (-f $path)
	{
		# TODO: allow this to be absent if all parsed options (i.e. mask) were provided as options to this script
		fatal("No file at: $path");
	}
	# parse the file for some options
	debug("Parsing run information file...");
	my $xml = XML::LibXML->load_xml(location => $path);
	my %options = ();
	# get the read masks (if requried)
	$options{'mask'} = $_options{'mask'};
	unless ($_options{'mask'})
	{
		# mask not supplied as option
		$options{'mask'} = join "," , map
			{
				$_->{IsIndexedRead} eq 'Y'
					? 'I' . $_->{NumCycles}
					: 'Y' . $_->{NumCycles};
			} $xml->findnodes('/RunInfo/Run/Reads/Read');
		debug("Parsed read mask: $options{'mask'}");
	}
	return %options;
}

=head1 SEE ALSO

L<projectctl>, L<RosenLab>, L<RosenLab::Log::Simple>

=head1 COPYRIGHT & LICENSE

This program is free software. Free as in freedom. Do whatever the hell you want
with it.

=cut

__DATA__

__END__
